<!doctype html>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#f4f7fb" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <title>Habitube â€” Les petites habitudes qui changent tout </title>
  <script src="https://www.gstatic.com/firebasejs/10.10.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.10.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.10.0/firebase-firestore-compat.js"></script>
  <script>
    const HABITU_FIREBASE_CONFIG = {
      apiKey: "AIzaSyD_dzzwWVEE0_aCMIbmbjPoYAj9Lzgb8J4",
      authDomain: "routine-buddy-2e6e5.firebaseapp.com",
      projectId: "routine-buddy-2e6e5",
      appId: "1:541875105784:web:cb5dc97a24afd05bae700d"
    };
    if (!firebase.apps.length) {
      firebase.initializeApp(HABITU_FIREBASE_CONFIG);
    }
    window.HABITU_FIREBASE_AUTH = firebase.auth();
    HABITU_FIREBASE_AUTH.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    window.HABITU_FIREBASE_DB = firebase.firestore();
  </script>
  <link rel="stylesheet" href="style.css" />

</head>

<body>
  <div class="loader-overlay hide" id="loaderOverlay">
    <div class="loader-content">
      <div class="loader-title">Habitube.com</div>
      <div class="loader-emoji" id="loaderEmoji">ğŸŒ±</div>
      <div class="loader-habit">
        <div class="loader-habit-tags" id="loaderHabitTags"></div>
        <div class="loader-habit-name" id="loaderHabitName">Une habitude</div>
      </div>
      <div class="loader-tip" id="loaderTip"></div>
    </div>
    <div class="loader-version" id="loaderVersion"></div>
  </div>
  <div class="toast-container" id="toastContainer"></div>
  <div class="install-prompt" id="installPromptCard">
    <div class="install-card">
      <h3>Installer Habitube</h3>
      <p>Ajoute Habitube Ã  ton Ã©cran dâ€™accueil et reste connectÃ© Ã  tes jardins partagÃ©s.</p>
      <div class="btn-row">
        <button class="btn primary" id="installPromptBtn">Installer</button>
        <button class="btn" id="installPromptClose">Plus tard</button>
      </div>
      <div class="learn-more" id="installPromptHelp">Pourquoi installer ?</div>
    </div>
  </div>
  <div class="auth-overlay hide" id="authOverlay">
    <div class="auth-card">
      <img src="icon-512.png" alt="Logo Habitube" />
      <div class="auth-message" id="authMessage">Connecte-toi pour retrouver tes habitudes</div>
      <div class="auth-space-desc" id="authSpaceDesc"></div>
      <div class="auth-forms">
        <form id="authForm">
          <input id="authEmail" type="email" required placeholder="Email" />
          <input id="authPassword" type="password" required placeholder="Mot de passe" />
          <div class="auth-link-row">
            <span id="forgotPasswordLink" class="auth-link">Mot de passe oubliÃ© ?</span>
          </div>
          <div class="auth-error" id="authError"></div>
          <div class="auth-actions">
            <button type="submit" id="authLoginBtn" data-action="login" class="text-btn primary">Se connecter</button>
            <button type="submit" id="authSignupBtn" data-action="signup" class="text-btn secondary">CrÃ©er mon
              compte</button>
          </div>

        </form>
        <div class="auth-separator">
          <span class="label">ou</span>
        </div>
        <button type="button" class="auth-guest-btn text-btn secondary" id="authGuestBtn">Se connecter en mode
          anonyme</button>
        <div class="auth-note" id="authNote">Nous gardons tes jardins privÃ©s.<br>Aucune donnÃ©e nâ€™est transmise Ã  des
          tiers.</div>
      </div>
      <div class="auth-helper" id="resetNotice"></div>
    </div>
  </div>
  <div id="app">
    <div class="top">
      <div class="brand" id="brand"><span class="logo">ğŸŒ±</span>Habitube</div>
      <div class="spacer"></div>
      <select id="spaceSel" class="select" title="Changer de jardin"></select>
      <button class="navbtn" id="openSpace" title="Jardin">â›­</button>
    </div>

    <div class="daysWrap" id="daysWrap">
      <button class="navbtn" id="prevDay">â†</button>
      <div class="rowInline rowInline-tight">
        <div class="dateLabel" id="dateLabel">â€”</div>
      </div>
      <div class="rightBtns">
        <button class="navbtn" id="nextDay">â†’</button>
        <button class="navbtn" id="addBtn" title="Menu">â˜°</button>
      </div>
    </div>

    <main id="home" class="view active">
      <div class="habit-filter" id="habitFilterBar" role="tablist" aria-label="Filtrer les habitudes"></div>
      <div class="list" id="cards"></div>
    </main>

    <section id="detail" class="view">
      <div class="detailHead">
        <button class="backMini" id="backHome">â†</button>
        <div class="detailTitle" id="detailTitle"></div>
      </div>
      <div class="tabs">
        <button class="tab" data-tab="gardeners">ğŸ§‘â€ğŸŒ¾ Jardiniers</button>
        <button class="tab active" data-tab="settings">âœï¸ Edition</button>
      </div>
      <div class="section">
        <div class="view active" id="tab-settings">
          <div class="grid">
            <div class="field">
              <label><b>Nom personnalisÃ©</b></label>
              <div class="inputEmoji">
                <span class="emojiPrefix" id="habitTitleEmoji">ğŸŒ±</span>
                <input id="habitTitleInput" type="text" placeholder="Nom de l'habitude" />
              </div>
            </div>

            <div class="field">
              <label><b>Note</b></label>
              <textarea id="habitDesc" placeholder="Ã‰tapes, conseils, instructions spÃ©cifiques..."></textarea>
            </div>

            <div class="field" id="recurrenceField">
              <label><b>RÃ©currence</b></label>
              <div class="recurrence-options" id="recurrenceOptions">
                <label><input type="radio" name="habitRecurrenceMode" value="weekly" checked /> Hebdomadaire</label>
                <label><input type="radio" name="habitRecurrenceMode" value="interval" /> Toutes les
                  <select id="habitRecurrenceInterval" class="select recurrence-interval">
                    <option value="">â€“</option>
                    <option value="2">2 semaines</option>
                    <option value="3">3 semaines</option>
                    <option value="4">4 semaines</option>
                  </select>
                </label>
              </div>
              <div class="freq-weekdays recurrence-days" id="habitRecurrenceDays">
                <label><input type="checkbox" value="1">Lundi</label>
                <label><input type="checkbox" value="2">Mardi</label>
                <label><input type="checkbox" value="3">Mercredi</label>
                <label><input type="checkbox" value="4">Jeudi</label>
                <label><input type="checkbox" value="5">Vendredi</label>
                <label><input type="checkbox" value="6">Samedi</label>
                <label><input type="checkbox" value="0">Dimanche</label>
              </div>
              <div class="recurrence-date-row">
                <div class="recurrence-date">
                  <label><b>DÃ©but</b></label>
                  <div class="recurrence-date__control">
                    <input id="habitStartDate" type="date" />
                  </div>
                </div>
                <div class="recurrence-date">
                  <label><b>Fin</b></label>
                  <div class="recurrence-date__control">
                    <input id="habitEndDate" type="date" placeholder="(aucun)" />
                  </div>
                </div>
              </div>
            </div>

            <div class="detail-actions">
              <button class="btn danger" id="deleteHabitBtn">Supprimer</button>
              <button class="btn primary" id="saveHabitBtn">Sauvegarder</button>
            </div>
          </div>
        </div>
        <div class="view" id="tab-gardeners">
          <div class="grid habit-gardeners">
            <div class="habit-gardeners-table">
              <table>
                <thead id="habitGardenersHeader">
                  <tr>
                    <th>#</th>
                    <th class="sortable" data-sort="owner" title="Trier par jardinier">Jardinier</th>
                    <th class="sortable" data-sort="window" title="Trier par les 30 derniers jours">30 jours</th>
                    <th class="sortable" data-sort="total" title="Trier par le total">Total</th>
                  </tr>
                </thead>
                <tbody id="habitGardenersBody"></tbody>
              </table>
              <div class="miniInfo hide" id="habitGardenersEmpty">Aucun jardinier enregistrÃ© pour cette habitude.</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="profile" class="view">
      <div class="detailHead profile-head">
        <button class="backMini" id="backFromProfile">â†</button>
        <div class="profile-meta">
          <div class="detailTitle" id="profileTitle"></div>
        </div>
        <div class="profile-head-actions">
          <button class="btn secondary hide" id="grantAccessBtn">ğŸ”— Redonner l'accÃ¨s</button>
          <button class="btn danger hide" id="removeFromGardenBtn">âŒ Retirer</button>
        </div>
      </div>
      <!-- rest remains -->
      <div class="rankHeader profile-period-row">
        <b>PÃ©riode</b>
        <div class="profile-period-buttons">
          <button class="btnToggle" id="profilePeriod7">7 jours</button>
          <button class="btnToggle active" id="profilePeriod30">30 jours</button>
          <button class="btnToggle" id="profilePeriodAll">Total</button>
        </div>
      </div>
      <div id="profileHabits" class="profile-habit-list"></div>
      <div class="subtitle hide" id="profileEmpty">Pas encore dâ€™activitÃ© sur cette pÃ©riode.</div>
    </section>
    <section id="space" class="view">
      <div class="detailHead">
        <button class="backMini" id="backFromSpace">â†</button>
        <div class="detailTitle" id="spaceHeaderTitle"></div>
        <div class="spacer"></div>
      </div>
      <div class="tabs">
        <button class="tab active" data-stab="sparams">âš™ï¸ RÃ©glages</button>
        <button class="tab" data-stab="sprofile">ğŸ‘¤ Profil</button>
        <button class="tab" data-stab="sstats">ğŸ“Š Stats</button>
      </div>
      <div class="section">
        <div class="view" id="sprofile">
          <div class="space-profile-visual">
            <div class="score-panel">
              <div class="score-title">Score hebdo</div>
              <div class="score-value">28</div>
              <div class="score-diff positive">+5 par rapport Ã  la semaine derniÃ¨re</div>
              <div class="score-bar">
                <span class="score-fill" style="width: 72%;"></span>
              </div>
              <div class="score-note">Objectif : 30 activitÃ©s validÃ©es</div>
            </div>
            <div class="needs-panel">
              <div class="needs-title">Top 3 des besoins</div>
              <div class="needs-list">
                <div class="need-pill">
                  <span class="need-emoji">ğŸ—‚ï¸</span>
                  <span class="need-label">Organisation</span>
                  <span class="need-percentage">82%</span>
                </div>
                <div class="need-pill">
                  <span class="need-emoji">ğŸ›‹ï¸</span>
                  <span class="need-label">Confort</span>
                  <span class="need-percentage">76%</span>
                </div>
                <div class="need-pill">
                  <span class="need-emoji">ğŸ</span>
                  <span class="need-label">Nutrition</span>
                  <span class="need-percentage">71%</span>
                </div>
              </div>
            </div>
          </div>
          <div class="space-badges">
            <h3>Badges de rÃ©compense</h3>
            <div class="badge-grid badge-grid-36">
              <div class="badge-chip">ğŸŒ± Initiateur de routine</div>
              <div class="badge-chip">ğŸ’§ Eau du matin</div>
              <div class="badge-chip">ğŸ¥— Assiette gourmande</div>
              <div class="badge-chip">ğŸ§˜ Respire tranquille</div>
              <div class="badge-chip">ğŸ§´ Rituel cocon</div>
              <div class="badge-chip">ğŸ§¹ EntrÃ©e lumineuse</div>
              <div class="badge-chip">ğŸ› Bain douceur</div>
              <div class="badge-chip">ğŸ—„ï¸ Bureau clair</div>
              <div class="badge-chip">ğŸ—ƒï¸ Ã‰tageres rangÃ©es</div>
              <div class="badge-chip">ğŸ§º Lessive fluide</div>
              <div class="badge-chip">ğŸ§» Stock rassurant</div>
              <div class="badge-chip">ğŸšŒ DÃ©part serein</div>
              <div class="badge-chip">ğŸ›£ï¸ Chemin inventif</div>
              <div class="badge-chip">ğŸ§° Mini bricoleur</div>
              <div class="badge-chip">ğŸ§­ Planificateur calme</div>
              <div class="badge-chip">ğŸ—‚ï¸ Notes alignÃ©es</div>
              <div class="badge-chip">ğŸ¥£ Matin partagÃ©</div>
              <div class="badge-chip">ğŸ½ï¸ Solo chef</div>
              <div class="badge-chip">ğŸª¥ Soin impeccable</div>
              <div class="badge-chip">ğŸƒ Pause nature</div>
              <div class="badge-chip">ğŸŒ¿ Marche lente</div>
              <div class="badge-chip">ğŸš½ Toilettes ordonnÃ©es</div>
              <div class="badge-chip">ğŸŒŸ Sourire gÃ©nÃ©reux</div>
              <div class="badge-chip">ğŸ‰ Humeur contagieuse</div>
              <div class="badge-chip">ğŸ’Œ Mot doux</div>
              <div class="badge-chip">ğŸ§¶ Inclusion tendre</div>
              <div class="badge-chip">ğŸ’¬ Astuce partage</div>
              <div class="badge-chip">ğŸ“ Voix amie</div>
              <div class="badge-chip">ğŸ§­ Projet accompli</div>
              <div class="badge-chip">ğŸ›Œ Repos retrouvÃ©</div>
              <div class="badge-chip">ğŸ“˜ Lecture quotidienne</div>
              <div class="badge-chip">ğŸš¶â€â™€ï¸ Escalier choisi</div>
              <div class="badge-chip">ğŸ® Pause joyeuse</div>
              <div class="badge-chip">ğŸ§© Casse-tÃªte fini</div>
              <div class="badge-chip">ğŸ§¿ Veille apaisÃ©e</div>
              <div class="badge-chip">ğŸŒˆ Regard bienveillant</div>
            </div>
          </div>
        </div>
        <div class="view active" id="sparams">
          <div class="grid">
            <div class="field hide" id="spaceProfileModeField">
              <label><b>Profil</b></label>
              <div class="profile-mode-options" role="radiogroup" aria-label="Choisir le profil de votre jardin">
                <button type="button" class="profile-mode-option" data-mode="local" aria-pressed="false">
                  <div class="profile-mode-option__name">ğŸ”’ PrivÃ©</div>
                  <div class="profile-mode-option__tag">Anonyme</div>
                </button>
                <button type="button" class="profile-mode-option" data-mode="minimal" aria-pressed="false">
                  <div class="profile-mode-option__name">ğŸ”— PartagÃ©</div>
                  <div class="profile-mode-option__tag">Confidentiel</div>
                </button>
                <button type="button" class="profile-mode-option" data-mode="complet" aria-pressed="false">
                  <div class="profile-mode-option__name">ğŸŒ Ouvert</div>
                  <div class="profile-mode-option__tag">Public</div>
                </button>
              </div>
              <div class="subtitle" id="profileModeHint"></div>
            </div>
            <div class="field hide" id="spacePseudoField">
              <label><b>Pseudo</b></label>
              <div class="rowInline">
                <input id="paramSpacePseudo" type="text" readonly placeholder="AloeCalme" />
              </div>
              <div class="subtitle">Ton pseudo est visible dans ton espace individuel.</div>
            </div>
            <div class="field"><label><b>PrÃ©nom affichÃ©</b></label><input id="paramName" type="text"
                placeholder="Moi" />
            </div>
            <div class="field" id="spaceLabelField"><label><b>Nom du jardin</b></label><input id="paramSpaceLabel"
                type="text" /></div>
            <div class="field" id="spaceIntroField">
              <label><b>Texte d'introduction</b></label>
              <textarea id="spaceDescInfo"
                placeholder="PrÃ©sentez le jardin, les rÃ¨gles et lâ€™Ã©tat dâ€™esprit. Cliquez pour Ã©diter."></textarea>
            </div>
            <div class="field" id="spaceRightsField">
              <label><b>Droits d'Ã©dition</b></label>
              <select id="spaceEditorRights" class="select">
                <option value="admin">Admin</option>
                <option value="registered">Utilisateurs enregistrÃ©s</option>
              </select>
            </div>
            <div class="field owner-controls hide" id="ownerControls">
              <div class="rowWrap">
                <button class="btn danger" id="deleteSpaceBtn">Supprimer le jardin</button>
              </div>
              <div class="subtitle" id="ownerControlsHint"></div>
            </div>
            <div class="field owner-controls hide" id="guestQuitControls">
              <div class="rowWrap">
                <button class="btn danger" id="quitSpaceBtn">Quitter le jardin</button>
              </div>
            </div>
            <div class="field">
              <label><b>Afficher les astuces</b></label>
              <select id="prefsTipsDisplayMode" class="select">
                <option value="auto">Auto</option>
                <option value="oui">Oui</option>
                <option value="non">Non</option>
              </select>
            </div>
            <div class="space-footer">
              <button class="btn danger hide reduced" id="deleteAccountBtn">Supprimer mon compte</button>
              <button class="btn primary" id="saveSpaceSettings">Sauvegarder</button>
            </div>
            <div class="subtitle" id="spaceSettingsNotice"></div>
          </div>
        </div>
        <div class="view" id="sstats">
          <div class="space-stats-table">
            <table>
              <thead>
                <tr>
                  <th>Habitude</th>
                  <th data-sortable="streak" data-direction="desc">Streak</th>
                  <th>Total</th>
                </tr>
              </thead>
              <tbody>
                <tr data-streak="14">
                  <td><span class="stat-emoji">ğŸ’§</span><span>Remplir sa gourde dâ€™eau</span></td>
                  <td>14 jours</td>
                  <td>62</td>
                </tr>
                <tr data-streak="12">
                  <td><span class="stat-emoji">ğŸ¥£</span><span>PrÃ©parer un petit-dÃ©jeuner commun</span></td>
                  <td>12 jours</td>
                  <td>58</td>
                </tr>
                <tr data-streak="10">
                  <td><span class="stat-emoji">ğŸ¤¸</span><span>Faire des Ã©tirements</span></td>
                  <td>10 jours</td>
                  <td>27</td>
                </tr>
                <tr data-streak="9">
                  <td><span class="stat-emoji">ğŸ</span><span>Manger plus de fruits</span></td>
                  <td>9 jours</td>
                  <td>41</td>
                </tr>
                <tr data-streak="7">
                  <td><span class="stat-emoji">â­</span><span>Se coucher avant 23h</span></td>
                  <td>7 jours</td>
                  <td>33</td>
                </tr>
                <tr data-streak="6">
                  <td><span class="stat-emoji">ğŸ“–</span><span>Lire 10 pages</span></td>
                  <td>6 jours</td>
                  <td>21</td>
                </tr>
                <tr data-streak="5">
                  <td><span class="stat-emoji">ğŸ’Œ</span><span>Partager une envie</span></td>
                  <td>5 jours</td>
                  <td>19</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="view" id="shistory">
          <div class="calendarWrap">
            <div class="calTop">
              <div class="calendar-controls">
                <button class="calBtn" id="sPrevMonth">â†</button>
                <div id="sMonthLabel" class="month-label"></div>
                <button class="calBtn" id="sNextMonth">â†’</button>
              </div>
              <div class="calendar-controls">
                <span class="caption-small">Voir :</span>
                <select id="sCalWho" class="select select-compact"></select>
              </div>
            </div>
            <div class="calendar" id="sCal"></div>
          </div>
        </div>
      </div>
    </section>
  </div>

  </div>

  <!-- Menu -->
  <div class="modal" id="modalAdd">
    <div class="sheet">
      <div class="sheetHeader">
        <div id="modalTitle">Menu</div><button class="closeX" id="closeAdd">â¨‰</button>
      </div>
      <div class="sheetBody">
        <div class="grid">
          <div class="opt" id="addHabit">
            <div class="emoji">ğŸŒ±</div>
            <div><b>Semer des graines</b>
              <div class="subtitle">DÃ©marrer des nouvelles routines</div>
            </div>
          </div>
          <div class="opt" id="inviteFriend">
            <div class="emoji">ğŸ’Œ</div>
            <div><b>Inviter un jardinier</b>
              <div class="subtitle">Partager un code d'accÃ¨s ou un lien d'invitation</div>
            </div>
          </div>
          <div class="opt hide" id="joinGarden">
            <div class="emoji">ğŸ§‘â€ğŸŒ¾</div>
            <div><b>Rejoindre un jardin</b>
              <div class="subtitle">Entrer un code d'accÃ¨s</div>
            </div>
          </div>
          <div class="opt hide" id="createGarden">
            <div class="emoji">ğŸ¡</div>
            <div><b>CrÃ©er un jardin</b>
              <div class="subtitle">Nouvel espace partagÃ©</div>
            </div>
          </div>
          <div class="opt" id="installApp">
            <div class="emoji">ğŸ“±</div>
            <div>
              <b>Installer l'application mobile</b>
              <div class="subtitle">Profite d'un accÃ¨s plus rapide et confortable</div>
            </div>
          </div>

          <div class="opt auth-action hide" id="menuLogin">
            <div class="emoji">ğŸ”</div>
            <div>
              <b>Se connecter Ã  un compte</b>
              <div class="subtitle">Retrouver ses jardins partagÃ©s en ligne</div>
            </div>
          </div>
          <div class="opt auth-action hide" id="menuLogout">
            <div class="emoji">ğŸ”“</div>
            <div>
              <b>Se dÃ©connecter</b>
              <div class="subtitle">Changer de compte</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Inviter -->
  <div class="modal" id="modalInvite">
    <div class="sheet">
      <div class="sheetHeader">
        <button type="button" class="backMini menu-back">â†</button>
        <div>Inviter</div><button class="closeX" id="closeInvite">â¨‰</button>
      </div>
      <div class="sheetBody">
        <div class="grid">
          <div class="field">
            <label><b>Identifiant du jardin</b></label>
            <input id="inviteGardenPseudo" type="text" readonly placeholder="â€”" />
            <div class="subtitle" id="joinSpaceDesc"></div>
          </div>

          <div class="field">
            <label><b>Pseudo du jardinier</b></label>
            <input id="invitePseudo" type="text" placeholder="ForetCalme" />
            <div class="subtitle">Ajoute un jardinier dÃ©jÃ  inscrit via son pseudo</div>
            <div class="rowInline">
              <button class="btn primary" id="addMemberByPseudo">Ajouter par pseudo</button>
            </div>
          </div>
          <div class="field">
            <label><b>Nouveau jardinier</b></label>
            <input id="inviteName" type="text" placeholder="PrÃ©nom" />
          </div>
          <div class="rowInline">
            <button class="btn primary" id="generateInvite">Inviter</button>
          </div>
          <div class="subtitle">Liste des invitations </div>
          <div id="inviteList" class="invite-list"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Habitude (bibliothÃ¨que multi-sÃ©lection) -->
  <div class="modal" id="modalHabit">
    <div class="sheet">
      <div class="sheetHeader">
        <button type="button" class="backMini menu-back">â†</button>
        <div id="habitTitle">Nouvelle(s) habitude(s)</div><button class="closeX" id="closeHabit">â¨‰</button>
      </div>
      <div class="sheetBody">
        <div class="grid" id="step1"></div>
        <div class="grid hide" id="step2"></div>
      </div>
    </div>
  </div>

  <!-- CrÃ©ation de jardin -->
  <div class="modal garden" id="modalGarden">
    <div class="sheet">
      <div class="sheetHeader">
        <button type="button" class="backMini menu-back">â†</button>
        <div>CrÃ©er un jardin</div>
      </div>
      <div class="sheetBody">
        <div class="garden-form">
          <div class="field">
            <label><b>Nom du jardin</b></label>
            <input id="gardenNameInput" type="text" placeholder="Nom du jardin" />
          </div>
          <div class="field">
            <label><b>Identifiant du jardin</b></label>
            <input id="gardenPseudoInput" type="text" placeholder="Identifiant du jardin" />
            <div class="subtitle">L'identifiant est utilisÃ© dans les invitations et les partages.</div>
          </div>
          <div class="field">
            <div class="rowInlineActions">
              <button class="btn primary" id="createGardenBtn">Suivant</button>
            </div>
            <div class="subtitle" id="gardenStatus"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal join" id="modalJoin">
    <div class="sheet">
      <div class="sheetHeader">
        <button type="button" class="backMini menu-back">â†</button>
        <div>Rejoindre un jardin</div>
      </div>
      <div class="sheetBody">
        <div class="grid">
          <div class="field">
            <label><b>PrÃ©nom</b></label>
            <input id="joinName" type="text" placeholder="Ton prÃ©nom" />
          </div>
          <div class="field">
            <label><b>Identifiant du jardin</b></label>
            <input id="joinPseudo" type="text" maxlength="16" placeholder="foret01" />
          </div>
          <div class="field">
            <div class="rowInlineActions">
              <button class="btn primary" id="joinSpaceBtn">Rejoindre</button>
            </div>
            <div class="subtitle" id="joinStatus"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="modal profile-setup" id="modalProfileSetup">
    <div class="sheet">
      <div class="sheetHeader">
        <div>Profil</div>
      </div>
      <div class="sheetBody">
        <div class="grid">
          <div class="field">
            <label><b>Profil</b></label>
            <select id="profileModeSelector" class="select">
              <option value="local">Local</option>
              <option value="minimal">Minimal</option>
              <option value="complet">Complet</option>
            </select>
            <div class="subtitle" id="profileModeSetupHint"></div>
          </div>
          <div class="field hide" id="profilePseudoField">
            <label><b>Pseudo</b></label>
            <div class="rowInline">
              <input id="profilePseudoInput" type="text" placeholder="doux-mousse-42" />
              <button type="button" class="btn mini refresh-btn" id="profilePseudoRefresh"
                title="GÃ©nÃ©rer un nouveau pseudo">
                âŸ²
              </button>
            </div>
          </div>
          <div class="field hide" id="profileNameField">
            <label><b>Nom affichÃ©</b></label>
            <input id="profileNameInput" type="text" placeholder="Moi" />
          </div>
          <div class="detail-actions">
            <button class="btn primary" id="profileSetupContinue">Commencer</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="cardContextMenu" class="card-context-menu" role="menu"></div>

  <script src="names.js"></script>
  <script src="library.js"></script>
  <script src="tips.js"></script>
  <script>
    /* ===== DonnÃ©es ===== */

    // Habitudes existantes (dÃ©mo) â€” espace individuel
    const CHALLENGES = [];
    const GROUP_CHALLENGES = [];
    const FAMILY_CHALLENGES = [];
    const ASSOCIATION_CHALLENGES = [];
    const OFFICE_CHALLENGES = [];
    const CLASS_CHALLENGES = [];

    // BibliothÃ¨que logistique : 20 habitudes non numÃ©riques, organisÃ©es en 10 catÃ©gories

    const LIBRARY_HABITS = [];
    const LIBRARY_CONTEXTS = [];
    const LIBRARY_NEEDS = [];
    const DEFAULT_PSEUDO_LIBRARY = {
      nouns: [
        'graine', 'feuille', 'tige', 'brin', 'mousse', 'seve', 'rosee', 'herbe', 'fleur', 'brume',
        'vent', 'nuage', 'roche', 'galet', 'sable', 'terre', 'bosse', 'lande', 'liege', 'pin',
        'orme', 'tille', 'saule', 'lierre', 'buis', 'jonc', 'roseau', 'trefle', 'lotus', 'iris',
        'noyer', 'chene', 'erable', 'ormeau', 'plume', 'foin', 'givre', 'ecume', 'onde', 'ruisseau',
        'source', 'bruit', 'buisson', 'sillon', 'branche', 'caillou', 'terreau', 'ronce', 'nene', 'ember'
      ],
      adjectives: [
        'doux', 'calme', 'pur', 'clair', 'pale', 'vif', 'sobre', 'simple', 'sage', 'leger', 'frais',
        'souple', 'subtil', 'brut', 'tendre', 'serein', 'vaporeux', 'fluide', 'dense', 'humble',
        'noble', 'lent', 'rapide', 'fort', 'fin', 'neuf', 'ancien', 'neutre', 'sec', 'moelleux',
        'brumeux', 'radieux', 'vibrant', 'epais', 'aerien', 'neigeux', 'marin', 'forestier', 'mince',
        'large', 'court', 'rond', 'ferme'
      ],
      locations: [
        'Foret', 'Prairie', 'Clairiere', 'Vallee', 'Riviere', 'Ruisseau', 'Marecage', 'Dune', 'Plage',
        'Colline', 'Plateau', 'Grotte', 'Sentier', 'Lagon', 'Baie', 'Crique', 'Oasis', 'Bosquet',
        'Haie', 'Sousbois', 'Mare', 'Marais', 'Archipel', 'Ilot', 'Lagune', 'Recif', 'Toundra',
        'Steppe', 'Taiga', 'Canyon', 'Desert', 'Falaises', 'Cascade', 'Versant', 'Source', 'Embouchure',
        'Delta', 'Promontoire', 'Sapinier', 'Pineraie', 'Bambouseraie', 'Rivage', 'Littoral', 'Lande',
        'Tourbiere', 'Belvedere', 'Corniche'
      ]
    };
    const PSEUDO_LIBRARY = {
      nouns: [...DEFAULT_PSEUDO_LIBRARY.nouns],
      adjectives: [...DEFAULT_PSEUDO_LIBRARY.adjectives],
      locations: [...DEFAULT_PSEUDO_LIBRARY.locations]
    };
    async function loadPseudoLibrary() {
      try {
        const source = (typeof window !== 'undefined' ? window.NAMES_LIBRARY_DATA : null) || null;
        const nouns = Array.isArray(source?.pseudoNouns) ? source.pseudoNouns : [];
        const adjectives = Array.isArray(source?.pseudoAdjectives) ? source.pseudoAdjectives : [];
        const locations = Array.isArray(source?.pseudoLocations) ? source.pseudoLocations : [];
        if (nouns.length) {
          PSEUDO_LIBRARY.nouns = nouns;
        }
        if (adjectives.length) {
          PSEUDO_LIBRARY.adjectives = adjectives;
        }
        if (locations.length) {
          PSEUDO_LIBRARY.locations = locations;
        }
      } catch (err) {
        console.warn('loadPseudoLibrary', err);
      }
      return PSEUDO_LIBRARY;
    }
    const PSEUDO_LIBRARY_READY = loadPseudoLibrary();

    /* Ã‰tats / stock */
    const HABIT_DESC = {}, HABIT_TITLE_CUSTOM = {}, SPACE_DESC_TXT = {};
    const BASE_MINUTES = {}, HABIT_MODE = {}, LOCKED_COMMUN = {}, LOCKED_BY = {}, DONE_SETS = {};
    const HAS_DESC = {}, DELETED_HABITS = new Set();
    const REPEAT_CONFIGS = {};

    /* Utils */
    const APP_VERSION = '0.0.38';
    const NEED_EMOJIS = {
      affection: 'â¤ï¸',
      joy: 'ğŸ˜„',
      joie: 'ğŸ˜„',
      calme: 'ğŸ•Šï¸',
      calm: 'ğŸ•Šï¸',
      nature: 'ğŸŒ¿',
      nutrition: 'ğŸ',
      organization: 'ğŸ—‚ï¸',
      organisation: 'ğŸ—‚ï¸',
      movement: 'ğŸƒ',
      mouvement: 'ğŸƒ',
      lien: 'ğŸ”—',
      sens: 'ğŸ¯',
      meaning: 'ğŸ¯',
      energie: 'âš¡',
      energy: 'âš¡',
      expression: 'ğŸ—£ï¸',
      communication: 'ğŸ—£ï¸',
      cooperation: 'ğŸ¤',
      participation: 'ğŸ™Œ',
      curiosity: 'ğŸ”',
      curiosite: 'ğŸ”',
      inclusion: 'ğŸŒˆ',
      equipment: 'ğŸ§°',
      comfort: 'ğŸ›‹ï¸',
      sleep: 'ğŸ˜´',
      sommeil: 'ğŸ˜´',
      rest: 'ğŸ˜´',
      entertainment: 'ğŸ­',
      cleaning: 'ğŸ§½',
      cleanliness: 'ğŸ§¼',
      hygiene: 'ğŸ§¼',
      privacy: 'ğŸ›¡ï¸',
      intimite: 'ğŸ›¡ï¸',
      slowness: 'ğŸ¢',
      lenteur: 'ğŸ¢'
    };
    const cardContextMenuEl = document.getElementById('cardContextMenu');
    const HABIT_FILTERS = [
      { key: 'todo', label: 'Ã€ faire', emptyText: 'Tu as fait le tour de ce filtre pour le moment.' },
      { key: 'done', label: 'Tous', emptyText: 'Aucune habitude prÃ©vue pour aujourdâ€™hui.' },
      { key: 'hidden', label: 'En pause', emptyText: 'Tu nâ€™as pas suspendu dâ€™habitude encore.' }
    ];
    let activeHabitFilter = 'todo';
    const habitFilterBarEl = document.getElementById('habitFilterBar');
    const habitFilterButtons = new Map();

    function getHabitFilterByKey(key) {
      return HABIT_FILTERS.find(filter => filter.key === key) || HABIT_FILTERS[0];
    }

    function updateHabitFilterButtons() {
      HABIT_FILTERS.forEach(filter => {
        const button = habitFilterButtons.get(filter.key);
        if (!button) return;
        button.classList.toggle('active', filter.key === activeHabitFilter);
      });
    }

    function renderHabitFilterBar() {
      if (!habitFilterBarEl) return;
      habitFilterBarEl.innerHTML = '';
      habitFilterButtons.clear();
      HABIT_FILTERS.forEach(filter => {
        const button = document.createElement('button');
        button.type = 'button';
        button.dataset.filterKey = filter.key;
        button.innerHTML = '';
        const labelSpan = document.createElement('span');
        labelSpan.textContent = filter.label;
        const countSpan = document.createElement('span');
        countSpan.className = 'habit-filter-count';
        countSpan.textContent = '0';
        button.append(labelSpan, countSpan);
        button.addEventListener('click', () => setHabitFilter(filter.key));
        habitFilterBarEl.appendChild(button);
        habitFilterButtons.set(filter.key, button);
      });
      updateHabitFilterButtons();
    }

    function updateHabitFilterCounts(counts = new Map()) {
      HABIT_FILTERS.forEach(filter => {
        const button = habitFilterButtons.get(filter.key);
        if (!button) return;
        const countEl = button.querySelector('.habit-filter-count');
        if (!countEl) return;
        const value = counts instanceof Map ? counts.get(filter.key) || 0 : counts[filter.key] || 0;
        countEl.textContent = String(value);
      });
    }

    function setHabitFilter(key) {
      if (!HABIT_FILTERS.some(filter => filter.key === key)) return;
      if (activeHabitFilter === key) return;
      activeHabitFilter = key;
      updateHabitFilterButtons();
      renderCards();
    }

    function habitMatchesFilter(filterKey, { state = 0, isHidden = false, dueToday = true } = {}) {
      const normalized = filterKey || HABIT_FILTERS[0].key;
      if (isHidden) {
        return normalized === 'hidden';
      }
      if (normalized === 'hidden') {
        return false;
      }
      if (!dueToday) {
        return false;
      }
      if (normalized === 'todo') {
        return state < 2;
      }
      if (normalized === 'done') {
        return true;
      }
      return true;
    }
    renderHabitFilterBar();
    let shouldSuppressCardClick = false;
    const CARD_CONTEXT_LONG_PRESS_MS = 360;
    function hideCardContextMenu() {
      if (!cardContextMenuEl) return;
      cardContextMenuEl.classList.remove('open');
    }
    function showCardContextMenu(habit, btn, clientX, clientY) {
      if (!cardContextMenuEl || !habit || !btn) return;
      cardContextMenuEl.innerHTML = '';
      let hasOption = false;
      const addOption = (label, handler) => {
        const option = document.createElement('button');
        option.type = 'button';
        option.textContent = label;
        option.addEventListener('click', (event) => {
          event.stopPropagation();
          handler();
        });
        cardContextMenuEl.appendChild(option);
        hasOption = true;
      };
      if (shouldShowContextMenuEdit()) {
        addOption('Ã‰diter', () => {
          hideCardContextMenu();
          openDetail(habit.id, btn);
        });
      }
      const isPinned = btn.dataset.pinned === '1';
      if (!isPinned) {
        addOption('Ã‰pingler', () => {
          hideCardContextMenu();
          pinHabitAction(habit.id);
        });
      }
      const isHidden = isHabitHidden(habit.id);
      if (isHidden) {
        addOption('Reprendre', () => {
          hideCardContextMenu();
          showHabit(habit.id);
        });
      }
      if (!isHidden) {
        addOption('Suspendre', () => {
          hideCardContextMenu();
          hideHabit(habit.id);
        });
      }
      if (!hasOption) return;
      cardContextMenuEl.style.left = '0px';
      cardContextMenuEl.style.top = '0px';
      cardContextMenuEl.classList.add('open');
      const rect = cardContextMenuEl.getBoundingClientRect();
      const safeLeft = Math.min(Math.max(8, clientX), Math.max(8, window.innerWidth - rect.width - 8));
      const safeTop = Math.min(Math.max(8, clientY), Math.max(8, window.innerHeight - rect.height - 8));
      cardContextMenuEl.style.left = `${safeLeft}px`;
      cardContextMenuEl.style.top = `${safeTop}px`;
      shouldSuppressCardClick = true;
      if (typeof window !== 'undefined' && window.getSelection) {
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          selection.removeAllRanges();
        }
      }
      setTimeout(() => { shouldSuppressCardClick = false; }, CARD_CONTEXT_LONG_PRESS_MS);
    }
    function attachCardContextHandlers(card, btn, habit) {
      if (!card || !btn || !habit) return;
      let longPressTimer = null;
      const clearLongPress = ({ preserveStart = false } = {}) => {
        const start = Number(btn.dataset.longPressStart) || 0;
        const elapsed = start ? Date.now() - start : 0;
        if (longPressTimer && elapsed < CARD_CONTEXT_LONG_PRESS_MS) {
          clearTimeout(longPressTimer);
        }
        longPressTimer = null;
        if (!preserveStart) {
          btn.dataset.longPressStart = '0';
        }
      };
      const startLongPress = (event) => {
        if (event.pointerType === 'mouse' && event.button !== 0) return;
        clearLongPress();
        btn.dataset.longPressStart = String(Date.now());
        longPressTimer = setTimeout(() => {
          longPressTimer = null;
          shouldSuppressCardClick = true;
          showCardContextMenu(habit, btn, event.clientX, event.clientY);
        }, CARD_CONTEXT_LONG_PRESS_MS);
      };
      card.addEventListener('pointerdown', startLongPress);
      card.addEventListener('pointerup', () => clearLongPress({ preserveStart: true }));
      card.addEventListener('pointerleave', () => clearLongPress());
      card.addEventListener('pointercancel', () => clearLongPress());
      card.addEventListener('contextmenu', (event) => {
        event.preventDefault();
        showCardContextMenu(habit, btn, event.clientX, event.clientY);
      });
    }
    document.addEventListener('pointerdown', (event) => {
      if (!cardContextMenuEl?.classList.contains('open')) return;
      if (!cardContextMenuEl.contains(event.target)) hideCardContextMenu();
    });
    window.addEventListener('scroll', hideCardContextMenu);
    window.addEventListener('resize', hideCardContextMenu);
    function slugifyTag(text) {
      const base = (text || '').toString();
      const normalized = base.normalize ? base.normalize('NFD') : base;
      return normalized
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/(^-|-$)+/g, '') || 'habitude';
    }
    function prettifyTag(tag) {
      if (!tag) return '';
      return tag
        .split(/[-_ ]+/)
        .filter(Boolean)
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }
    const TAG_TRANSLATIONS = {
      affection: 'Affection',
      calm: 'Calme',
      cleanliness: 'PropretÃ©',
      comfort: 'Confort',
      communication: 'Communication',
      cooperation: 'CoopÃ©ration',
      curiosity: 'CuriositÃ©',
      entertainment: 'Divertissement',
      equipment: 'MatÃ©riel',
      expression: 'Expression',
      hygiene: 'HygiÃ¨ne',
      inclusion: 'Inclusion',
      joy: 'Joie',
      meaning: 'Sens',
      movement: 'Mouvement',
      nature: 'Nature',
      nutrition: 'Nutrition',
      organization: 'Organisation',
      participation: 'Participation',
      privacy: 'IntimitÃ©',
      rest: 'Repos',
      safety: 'SÃ©curitÃ©',
      school: 'Ã‰cole',
      sleep: 'Sommeil',
      slowness: 'Lenteur',
      social: 'Social',
      family: 'Famille',
      home: 'Maison',
      office: 'Bureau',
      outdoor: 'ExtÃ©rieur'
    };
    const MODE_META = {
      libre: { label: 'Individuel', shortLabel: 'Moi ğŸ‘¤', emoji: 'ğŸ‘¤', target: 'individual' },
      commun: { label: 'PartagÃ©', shortLabel: 'Tout le monde ğŸ‘¥', emoji: 'ğŸ‘¥', target: 'group' }
    };
    const PSEUDO_LIBRARY_MAX_ATTEMPTS = 6;
    function sanitizePseudo(value) {
      const input = (value || '').toString();
      const normalized = input.normalize ? input.normalize('NFD') : input;
      return normalized
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '')
        .trim();
    }
    function titleCase(word) {
      const base = (word || '').toString().trim();
      if (!base) return '';
      const normalized = base.normalize ? base.normalize('NFD') : base;
      const clean = normalized.replace(/[\u0300-\u036f]/g, '').toLowerCase();
      return clean.charAt(0).toUpperCase() + clean.slice(1);
    }
    function buildUserPseudo(adjective, noun) {
      const n = titleCase(noun);
      const adj = titleCase(adjective);
      return `${n}${adj}`.trim();
    }
    function buildGardenPseudo(location, suffix = '') {
      const loc = titleCase(location);
      const numeric = suffix ? String(suffix).padStart(2, '0').slice(-2) : '';
      return `${loc}${numeric}`;
    }
    function normalizeSpacePseudo(value) {
      const raw = sanitizePseudo(value);
      return raw ? raw.toLowerCase() : '';
    }
    async function isPseudoTaken(pseudo) {
      if (!pseudo || !HABITU_FIREBASE_DB) return false;
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('users')
          .where('pseudo', '==', pseudo)
          .limit(1)
          .get();
        if (!snapshot || snapshot.empty) return false;
        const doc = snapshot.docs[0];
        if (currentProfile?.uid && doc.id === currentProfile.uid) return false;
        return true;
      } catch (err) {
        console.warn('isPseudoTaken', err);
        return false;
      }
    }
    async function isSpacePseudoTaken(pseudo, excludeId = null) {
      if (!pseudo) return false;
      const normalized = normalizeSpacePseudo(pseudo);
      const localMatch = Object.keys(SPACES).some(id => {
        if (excludeId && id === excludeId) return false;
        return normalizeSpacePseudo(SPACES[id]?.pseudo) === normalized;
      });
      if (localMatch) return true;
      if (!HABITU_FIREBASE_DB) return false;
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('spaces')
          .where('pseudoNormalized', '==', normalized)
          .limit(1)
          .get();
        if (!snapshot || snapshot.empty) return false;
        const doc = snapshot.docs[0];
        if (excludeId && doc.id === excludeId) return false;
        return true;
      } catch (err) {
        console.warn('isSpacePseudoTaken', err);
        return false;
      }
    }
    async function generateUniquePseudo(attempt = 0) {
      await PSEUDO_LIBRARY_READY;
      const nouns = PSEUDO_LIBRARY.nouns.length ? PSEUDO_LIBRARY.nouns : DEFAULT_PSEUDO_LIBRARY.nouns;
      const adjectives = PSEUDO_LIBRARY.adjectives.length ? PSEUDO_LIBRARY.adjectives : DEFAULT_PSEUDO_LIBRARY.adjectives;
      const pick = (arr) => arr[Math.floor(Math.random() * arr.length)] || '';
      const candidateRaw = buildUserPseudo(pick(adjectives), pick(nouns));
      const candidate = sanitizePseudo(candidateRaw);
      if (!candidate) return '';
      if (await isPseudoTaken(candidate) || await isSpacePseudoTaken(candidate)) {
        if (attempt >= PSEUDO_LIBRARY_MAX_ATTEMPTS) {
          return sanitizePseudo(`${candidate}${String(attempt).padStart(2, '0')}`);
        }
        return generateUniquePseudo(attempt + 1);
      }
      return candidate;
    }
    async function generateUniqueGardenPseudo(attempt = 0) {
      await PSEUDO_LIBRARY_READY;
      const locations = PSEUDO_LIBRARY.locations.length ? PSEUDO_LIBRARY.locations : DEFAULT_PSEUDO_LIBRARY.locations;
      const pick = (arr) => arr[Math.floor(Math.random() * arr.length)] || '';
      const suffix = String(Math.floor(Math.random() * 100)).padStart(2, '0');
      const candidateRaw = buildGardenPseudo(pick(locations), suffix);
      const candidate = sanitizePseudo(candidateRaw);
      if (!candidate) return '';
      if (await isSpacePseudoTaken(candidate)) {
        if (attempt >= PSEUDO_LIBRARY_MAX_ATTEMPTS) {
          return sanitizePseudo(`${candidate}${String(Math.floor(Math.random() * 90) + 10)}`);
        }
        return generateUniqueGardenPseudo(attempt + 1);
      }
      return candidate;
    }
    async function ensureSpaceHasPseudo(targetSpaceId) {
      if (!targetSpaceId) return null;
      const space = SPACES[targetSpaceId];
      if (!space) return null;
      const current = space.pseudo || '';
      if (current) {
        space.pseudo = current;
        space.pseudoNormalized = normalizeSpacePseudo(current);
        return current;
      }
      const candidate = await generateUniqueGardenPseudo();
      if (!candidate) return null;
      space.pseudo = candidate;
      space.pseudoNormalized = normalizeSpacePseudo(candidate);
      await persistSpaceDoc(targetSpaceId, { pseudo: candidate });
      return candidate;
    }
    const CONTEXT_EMOJIS = {
      family: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦',
      home: 'ğŸ¡',
      office: 'ğŸ¢',
      school: 'ğŸ«',
      social: 'ğŸ§‘â€ğŸ¤â€ğŸ§‘',
      outdoor: 'ğŸŒ³'
    };
    function normalizeTagKey(tag) {
      if (!tag) return '';
      const value = tag.toString();
      const normalized = value.normalize ? value.normalize('NFD') : value;
      return normalized.replace(/[\u0300-\u036f]/g, '').toLowerCase().trim();
    }
    function translateTag(tag) {
      const key = normalizeTagKey(tag);
      return TAG_TRANSLATIONS[key] || prettifyTag(tag);
    }
    function getTagEmoji(tag, type) {
      if (!type) return '';
      const key = normalizeTagKey(tag);
      const emojiMap = type === 'context' ? CONTEXT_EMOJIS : type === 'need' ? NEED_EMOJIS : null;
      return emojiMap?.[key] || '';
    }
    function formatTagLabel(tag, type) {
      const label = translateTag(tag);
      const emoji = getTagEmoji(tag, type);
      return `${emoji ? `${emoji} ` : ''}${label}`;
    }

    const FALLBACK_LOADER_HABITS = [
      { id: 'fallback-1', emoji: 'ğŸŒ±', title: 'Cultiver un rituel matinal' },
      { id: 'fallback-2', emoji: 'ğŸŒ¿', title: 'Respirer profondÃ©ment' },
      { id: 'fallback-3', emoji: 'ğŸŒ¸', title: 'Faire une pause hydratation' },
      { id: 'fallback-4', emoji: 'ğŸŒ', title: 'Programmer un sourire' },
      { id: 'fallback-5', emoji: 'ğŸŒ»', title: 'Noter un petit mÃ©rite' }
    ];
    const FALLBACK_LOADER_TIPS = [
      "Respire profondÃ©ment trois fois avant de commencer.",
      "PrÃ©pare ton espace pour Ã©viter la procrastination.",
      "Rappelle-toi pourquoi cette habitude compte pour toi.",
      "Commence petit et laisse-toi la place pour ajuster.",
      "CÃ©lÃ¨bre un petit progrÃ¨s, mÃªme discret.",
      "Partage ton avancÃ©e avec un proche motivant."
    ];
    const DEFAULT_DURATION = 15;
    const DEFAULT_GARDENER_WINDOW_DAYS = 30;
    let PERSONAL_ACTIVITY_CACHE = [];
    let PERSONAL_ACTIVITY_CACHE_DAYS = DEFAULT_GARDENER_WINDOW_DAYS;
    let PERSONAL_ACTIVITY_LAST_REFRESH = 0;
    let personalActivityRefreshPromise = null;
    const PERSONAL_ACTIVITY_REFRESH_INTERVAL_MS = 3 * 60 * 1000;
    const LOADER_ROTATION_MS = 60000;
    const $ = s => document.querySelector(s), $$ = s => Array.from(document.querySelectorAll(s));
    const setLoaderVersion = () => {
      const versionEl = $('#loaderVersion');
      if (versionEl) {
        versionEl.textContent = `v${APP_VERSION}`;
      }
    };
    function getLoaderHabitCandidates() {
      const librarySource = LIBRARY_HABITS.length ? LIBRARY_HABITS : (Array.isArray(window.LIBRARY_JSON_DATA) ? window.LIBRARY_JSON_DATA : []);
      if (librarySource.length) return librarySource;
      return FALLBACK_LOADER_HABITS;
    }
    function getLoaderMinuteSeed() {
      const now = Date.now();
      return String(Math.floor(now / 60000));
    }
    function pickLoaderHabit(seed = '') {
      const normalizedSeed = String(seed || getLoaderMinuteSeed());
      const candidates = getLoaderHabitCandidates();
      if (!candidates.length) {
        return { emoji: 'ğŸŒ±', title: 'Une habitude', index: 0 };
      }
      const hash = hashStr(`loader:${normalizedSeed}`);
      const idx = ((hash % candidates.length) + candidates.length) % candidates.length;
      const habit = candidates[idx];
      const label = habit.title || habit.titre || 'Une habitude';
      const indexValue = habit.id ?? (idx + 1);
      return { emoji: habit.emoji || 'ğŸŒ±', title: label, index: indexValue, habit };
    }
    function refreshLoaderHabit(seed = '') {
      const info = pickLoaderHabit(seed);
      const emojiEl = $('#loaderEmoji');
      const nameEl = $('#loaderHabitName');
      if (emojiEl) emojiEl.textContent = info.emoji || 'ğŸŒ±';
      if (nameEl) nameEl.textContent = info.title || 'Une habitude';
      return info;
    }
    function getHabitTips(habit) {
      const normalized = [];
      if (Array.isArray(habit?.tips)) {
        habit.tips.forEach(tip => {
          if (typeof tip === 'string' && tip.trim()) {
            normalized.push(tip.trim());
          }
        });
      }
      if (typeof window !== 'undefined' && Array.isArray(window.HABIT_TIPS)) {
        const habitId = habit?.id ?? habit?.hid ?? habit?.habitId;
        if (habitId !== undefined && habitId !== null) {
          const idKey = String(habitId);
          window.HABIT_TIPS.forEach(entry => {
            if (!entry || entry.id == null) return;
            if (String(entry.id) !== idKey) return;
            const tipText = entry.title;
            if (typeof tipText === 'string') {
              const trimmed = tipText.trim();
              if (trimmed && !normalized.includes(trimmed)) {
                normalized.push(trimmed);
              }
            }
          });
        }
      }
      return normalized;
    }
    function pickLoaderTip(seed = '', habit = null) {
      const normalizedSeed = String(seed || getLoaderMinuteSeed());
      const tips = getHabitTips(habit);
      const candidates = tips.length ? tips : FALLBACK_LOADER_TIPS;
      if (!candidates.length) {
        return { text: '' };
      }
      const hash = hashStr(`loader-tip:${habit?.id ?? habit?.title ?? 'fallback'}:${normalizedSeed}`);
      const idx = ((hash % candidates.length) + candidates.length) % candidates.length;
      return { text: candidates[idx] || '' };
    }
    function refreshLoaderTip(seed = '', habit = null) {
      const tipEl = $('#loaderTip');
      if (!tipEl) return;
      const info = pickLoaderTip(seed, habit);
      const tipText = info.text || 'Une astuce pour dÃ©marrer.';
      tipEl.textContent = `ğŸ’¡${tipText}`;
    }
    function buildLoaderHabitTags(habit) {
      if (!habit) return ['#habitude'];
      const sources = [];
      ['needs', 'contexts', 'tags'].forEach(key => {
        const values = habit?.[key];
        if (Array.isArray(values)) {
          values.forEach(value => {
            if (value) sources.push(value);
          });
        }
      });
      const seen = new Set();
      const tags = [];
      sources.forEach(value => {
        const translated = translateTag(value) || value?.toString?.();
        const slug = slugifyTag(translated || value);
        if (!slug) return;
        if (seen.has(slug)) return;
        seen.add(slug);
        tags.push(`#${slug}`);
      });
      return tags.length ? tags.slice(0, 3) : ['#habitude'];
    }
    function refreshLoaderTags(habit) {
      const tagsEl = $('#loaderHabitTags');
      if (!tagsEl) return;
      const tags = buildLoaderHabitTags(habit);
      tagsEl.textContent = tags.join(' ');
    }
    function refreshLoader(seed = '') {
      const info = refreshLoaderHabit(seed);
      refreshLoaderTip(seed, info.habit);
      refreshLoaderTags(info.habit);
      return info;
    }
    setLoaderVersion();
    refreshLoader(getLoaderMinuteSeed());
    /* ===== Sticky header offsets ===== */
    const stickyRoot = document.documentElement;
    function refreshStickyOffsets() {
      const topElement = document.querySelector('.top');
      const topHeight = topElement ? topElement.offsetHeight : 0;
      stickyRoot.style.setProperty('--top-sticky-offset', `${topHeight}px`);
      const activeDetailHead = document.querySelector('.view.active .detailHead');
      if (activeDetailHead) {
        stickyRoot.style.setProperty('--detail-head-height', `${activeDetailHead.offsetHeight}px`);
      }
    }
    let stickyRefreshScheduled = false;
    function scheduleStickyRefresh() {
      if (stickyRefreshScheduled) return;
      stickyRefreshScheduled = true;
      requestAnimationFrame(() => {
        stickyRefreshScheduled = false;
        refreshStickyOffsets();
      });
    }
    const viewObserver = new MutationObserver(scheduleStickyRefresh);
    document.querySelectorAll('.view').forEach(view => viewObserver.observe(view, { attributes: true, attributeFilter: ['class'] }));
    const bodyObserver = new MutationObserver(scheduleStickyRefresh);
    bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
    window.addEventListener('resize', refreshStickyOffsets);
    refreshStickyOffsets();
    function fmtDate(d) { const M = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'][d.getMonth()]; const j = String(d.getDate()).padStart(2, '0'); const J = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'][d.getDay()]; return `${J} ${j}/${M}`; }
    function parseDateInput(value) {
      if (!value) return null;
      if (value instanceof Date) {
        const copy = new Date(value);
        copy.setHours(0, 0, 0, 0);
        return copy;
      }
      const normalized = String(value || '').trim();
      if (!/^\d{4}-\d{2}-\d{2}$/.test(normalized)) return null;
      const parsed = new Date(normalized);
      if (Number.isNaN(parsed.getTime())) return null;
      parsed.setHours(0, 0, 0, 0);
      return parsed;
    }
    function toIsoDateString(value) {
      const date = parseDateInput(value);
      if (!date) return '';
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }
    function getWeekdayOrdinalInfo(date) {
      if (!date) return { ordinal: 1, isLast: false };
      const targetWeekday = date.getDay();
      let ordinal = 0;
      for (let day = 1; day <= date.getDate(); day++) {
        const candidate = new Date(date.getFullYear(), date.getMonth(), day);
        if (candidate.getDay() === targetWeekday) {
          ordinal += 1;
        }
      }
      const nextWeek = new Date(date);
      nextWeek.setDate(nextWeek.getDate() + 7);
      const isLast = nextWeek.getMonth() !== date.getMonth();
      return { ordinal, isLast };
    }
    function daysBetween(start, end) {
      const a = parseDateInput(start);
      const b = parseDateInput(end);
      if (!a || !b) return 0;
      return Math.round((b - a) / 86400000);
    }
    function weeksBetween(start, end) {
      const a = getWeekStart(parseDateInput(start) || new Date());
      const b = getWeekStart(parseDateInput(end) || new Date());
      if (!a || !b) return 0;
      return Math.round((b - a) / 604800000);
    }
    function monthsBetween(start, end) {
      const a = parseDateInput(start);
      const b = parseDateInput(end);
      if (!a || !b) return 0;
      return (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
    }
    function normalizeRepeatConfig(habit, override = {}) {
      const fallbackUnit = 'day';
      const normalizedUnit = (override.unit || habit?.repeatConfig?.unit || fallbackUnit || 'day').toString().toLowerCase();
      const unit = normalizedUnit === 'week' ? 'week' : 'day';
      const baselineDate = parseDateInput(override.startDate || habit?.repeatConfig?.startDate || habit?.startDate || habit?.addedAt || curDate()) || curDate();
      const intervalCandidate = override.interval ?? habit?.frequency ?? 1;
      const interval = Math.max(1, Number.isFinite(Number(intervalCandidate)) ? Number(intervalCandidate) : 1);
      let weekDays = Array.isArray(override.weekDays) ? override.weekDays.map(normalizeDayIndex).filter(day => day !== null) : null;
      if (!weekDays || !weekDays.length) {
        if (Array.isArray(habit?.repeatConfig?.weekDays) && habit.repeatConfig.weekDays.length) {
          weekDays = habit.repeatConfig.weekDays.map(normalizeDayIndex).filter(day => day !== null);
        } else {
          weekDays = [];
        }
      }
      if (!weekDays.length && unit === 'week') {
        weekDays.push(baselineDate.getDay());
      }
      weekDays = Array.from(new Set(weekDays));
      const startDate = toIsoDateString(baselineDate) || toIsoDateString(curDate());
      const endDateCandidate = override.endDate ?? habit?.repeatConfig?.endDate ?? '';
      const endDate = toIsoDateString(endDateCandidate);
      return {
        interval,
        unit,
        startDate,
        endDate,
        weekDays
      };
    }
    function cacheRepeatConfigFromHabit(habit) {
      if (!habit || !habit.id) return null;
      const cached = normalizeRepeatConfig(habit, habit.repeatConfig || {});
      REPEAT_CONFIGS[habit.id] = cached;
      habit.repeatConfig = { ...cached };
      return cached;
    }
    function getHabitRepeatConfig(habit) {
      if (!habit) return normalizeRepeatConfig(null, {});
      if (habit.id && REPEAT_CONFIGS[habit.id]) {
        return REPEAT_CONFIGS[habit.id];
      }
      return cacheRepeatConfigFromHabit(habit);
    }
    function getHabitRepeatConfigById(habitId) {
      const habit = findAny(habitId);
      return getHabitRepeatConfig(habit);
    }
    function genCode() { const c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let s = ''; for (let i = 0; i < 6; i++)s += c[Math.floor(Math.random() * c.length)]; return s; }
    function generateSpaceId() {
      if (window.crypto?.randomUUID) {
        return crypto.randomUUID();
      }
      if (window.crypto?.getRandomValues) {
        const bytes = new Uint8Array(16);
        crypto.getRandomValues(bytes);
        const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
      }
      return `G${genCode()}`;
    }
    function inviteBaseUrl() {
      const pathname = window.location.pathname.replace(/\/index\.html$/i, '/');
      return `${window.location.origin}${pathname}`;
    }
    function genInviteToken() {
      if (window.crypto?.randomUUID) {
        return crypto.randomUUID().replace(/-/g, '');
      }
      if (window.crypto?.getRandomValues) {
        const bytes = new Uint8Array(16);
        crypto.getRandomValues(bytes);
        return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      return genCode();
    }
    const round15 = m => Math.round(m / 15) * 15;
    function lvlEmoji(v) { if (v <= 7) return 'ğŸŒ±'; if (v <= 14) return 'ğŸŒ¼'; if (v <= 21) return 'ğŸŒ»'; if (v <= 28) return 'ğŸŒ·'; if (v <= 35) return 'ğŸŒ¹'; if (v <= 42) return 'ğŸª»'; if (v <= 49) return 'ğŸ’'; return 'ğŸ‹'; }
    function names(xs, m = 3) { if (xs.length <= m) return xs.join(', '); const s = xs.slice(0, m).join(', '); return `${s}â€¦ et ${xs.length - m} autres`; }
    const INSTALL_PROMPT_STORAGE_KEY = 'habitu-install-prompt-seen';
    const INSTALL_PROMPT_SUPPRESSION_MS = 15 * 24 * 60 * 60 * 1000;
    const INSTALL_PROMPT_FIRST_HABIT_KEY = 'habitu-install-first-habit';
    const STORAGE_LAST_MEMBER_NAME = 'habitu-last-member-name';
    let deferredInstallPrompt = null;
    let installPromptAutoShown = false;
    let toastContainerEl = null;

    function safeStorageGet(key) {
      try {
        return localStorage.getItem(key);
      } catch (e) {
        return null;
      }
    }
    function safeStorageSet(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) { }
    }
    function getLastMemberName() {
      return safeStorageGet(STORAGE_LAST_MEMBER_NAME) || '';
    }
    function setLastMemberName(value) {
      safeStorageSet(STORAGE_LAST_MEMBER_NAME, (value || '').trim());
    }
    function ensureToastContainer() {
      if (!toastContainerEl) {
        toastContainerEl = $("#toastContainer");
      }
      return toastContainerEl;
    }
    function showToast(message, { type = 'info', duration = 1500 } = {}) {
      if (!message) return;
      const container = ensureToastContainer();
      if (!container) return;
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      container.appendChild(toast);
      const exitDelay = Math.max(duration - 250, 0);
      setTimeout(() => {
        toast.classList.add('toast-out');
      }, exitDelay);
      setTimeout(() => {
        toast.remove();
      }, duration);
    }
    function isRunningAsPWA() {
      if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) return true;
      if (navigator.standalone) return true;
      return false;
    }
    function hasCreatedInitialHabits() {
      return safeStorageGet(INSTALL_PROMPT_FIRST_HABIT_KEY) === '1';
    }
    function markFirstHabitCreated() {
      if (hasCreatedInitialHabits()) return;
      safeStorageSet(INSTALL_PROMPT_FIRST_HABIT_KEY, '1');
      maybeShowInstallPrompt(false);
    }
    function getInstallPromptTimestamp() {
      const value = safeStorageGet(INSTALL_PROMPT_STORAGE_KEY);
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    function hasSeenInstallPrompt() {
      const timestamp = getInstallPromptTimestamp();
      if (!timestamp) return false;
      return (Date.now() - timestamp) < INSTALL_PROMPT_SUPPRESSION_MS;
    }
    function markInstallPromptSeen() {
      safeStorageSet(INSTALL_PROMPT_STORAGE_KEY, String(Date.now()));
    }
    function showInstallPromptCard() {
      const card = $("#installPromptCard");
      if (card) card.classList.add('visible');
    }
    function closeInstallPromptCard() {
      const card = $("#installPromptCard");
      if (card) card.classList.remove('visible');
    }
    function updateInstallOptionVisibility() {
      const opt = $("#installApp");
      if (!opt) return;
      const hidden = !deferredInstallPrompt || isRunningAsPWA();
      opt.classList.toggle('hide', hidden);
    }
    function triggerInstallPrompt(source = 'manual') {
      if (!deferredInstallPrompt) {
        showToast('Installation indisponible pour le moment.', { type: 'error' });
        return;
      }
      deferredInstallPrompt.prompt();
      deferredInstallPrompt.userChoice.then(choice => {
        if (choice && choice.outcome === 'accepted') {
          showToast('Habitube est installÃ© !', { type: 'success' });
        } else if (source === 'auto') {
          showToast('Tu peux installer Habitube depuis ce bouton.', { type: 'info' });
        } else {
          showToast('Installation annulÃ©e.', { type: 'error' });
        }
        markInstallPromptSeen();
        deferredInstallPrompt = null;
        closeInstallPromptCard();
        updateInstallOptionVisibility();
      }).catch(err => {
        console.warn('triggerInstallPrompt', err);
        showToast('Impossible dâ€™installer pour lâ€™instant.', { type: 'error' });
      });
    }
    function maybeShowInstallPrompt(auto = true) {
      if (!hasCreatedInitialHabits()) return;
      if (isRunningAsPWA() || installPromptAutoShown || hasSeenInstallPrompt()) return;
      if (!deferredInstallPrompt) return;
      showInstallPromptCard();
      installPromptAutoShown = true;
    }
    window.addEventListener('beforeinstallprompt', (event) => {
      if (isRunningAsPWA()) return;
      event.preventDefault();
      deferredInstallPrompt = event;
      updateInstallOptionVisibility();
      maybeShowInstallPrompt(false);
    });
    const MIN_DAY_OFF = -3650;
    const FULL_WEEK_DAYS = [0, 1, 2, 3, 4, 5, 6];
    const WEEKDAY_ORDER = [1, 2, 3, 4, 5, 6, 0];
    const WEEKDAY_SHORT_LABELS = ['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa'];
    const WEEKDAY_BADGE_LABEL = { 1: 'L', 2: 'Ma', 3: 'Me', 4: 'J', 5: 'V', 6: 'S', 0: 'D' };

    function normalizeDayList(list) {
      if (!Array.isArray(list)) return [];
      const seen = new Set();
      return list.map(value => normalizeDayIndex(value))
        .filter(day => day !== null)
        .filter(day => {
          if (seen.has(day)) return false;
          seen.add(day);
          return true;
        });
    }

    function normalizeDayIndex(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return null;
      const floored = Math.floor(num);
      return ((floored % 7) + 7) % 7;
    }

    function buildHabitRecurrenceLabel(habit) {
      const repeatConfig = getHabitRepeatConfig(habit);
      if (!repeatConfig) return '';
      let days = [];
      if (repeatConfig.unit === 'week' && repeatConfig.weekDays.length) {
        days = repeatConfig.weekDays.slice();
      } else if (repeatConfig.unit === 'day') {
        days = WEEKDAY_ORDER.slice();
      }
      if (!days.length) return '';
      const orderedDays = WEEKDAY_ORDER.filter(day => days.includes(day));
      const labelDays = orderedDays.map(day => WEEKDAY_BADGE_LABEL[day]).filter(Boolean).join('');
      if (!labelDays) return '';
      const everyWeekDay = WEEKDAY_ORDER.length && WEEKDAY_ORDER.every(day => orderedDays.includes(day));
      if (everyWeekDay) {
        const dailyLabel = 'Quotidien';
        if (repeatConfig.unit === 'week' && repeatConfig.interval > 1) {
          return `${dailyLabel} /${repeatConfig.interval}`;
        }
        return dailyLabel;
      }
      if (repeatConfig.unit === 'week' && repeatConfig.interval > 1) {
        return `${labelDays} /${repeatConfig.interval}`;
      }
      return labelDays;
    }

    function getSelectedRecurrenceMode(modeRadios) {
      return modeRadios.find(radio => radio.checked)?.value || 'daily';
    }

    function configureRecurrenceDayInputsForMode(dayInputs, isInterval) {
      if (!dayInputs.length) return;
      dayInputs.forEach(input => {
        input.type = isInterval ? 'radio' : 'checkbox';
        input.name = isInterval ? 'habitRecurrenceDayRadio' : `habitRecurrenceDay${input.value}`;
      });
    }

    function applyRecurrenceMode(mode, { modeRadios, intervalSelect, dayInputs, isAdmin }) {
      const normalizedMode = mode === 'daily' ? 'weekly' : mode;
      modeRadios.forEach(radio => {
        radio.checked = radio.value === normalizedMode;
      });
      if (intervalSelect) {
        if (normalizedMode === 'interval') {
          if (!intervalSelect.value) {
            intervalSelect.value = intervalSelect.dataset.savedValue || intervalSelect.dataset.defaultInterval || '2';
          }
        } else {
          const fallback = intervalSelect.value || intervalSelect.dataset.savedValue || intervalSelect.dataset.defaultInterval || '2';
          intervalSelect.dataset.savedValue = fallback;
          intervalSelect.value = '';
        }
        intervalSelect.disabled = !isAdmin || normalizedMode !== 'interval';
      }
      configureRecurrenceDayInputsForMode(dayInputs, normalizedMode === 'interval');
    }

    function bindRecurrenceDaySelectionBehavior(dayInputs, getSelectedMode) {
      if (!dayInputs.length) return;
      dayInputs.forEach(input => {
        if (input.dataset.boundDay) return;
        input.addEventListener('change', () => {
          if (getSelectedMode() === 'interval' && input.checked) {
            dayInputs.forEach(other => {
              if (other === input) return;
              other.checked = false;
            });
          }
        });
        input.dataset.boundDay = '1';
      });
    }

    function setRecurrenceDaysOnInputs(dayInputs, days, isAdmin) {
      if (!dayInputs.length) return;
      const normalized = normalizeDayList(days);
      dayInputs.forEach(input => {
        const dayValue = normalizeDayIndex(input.value);
        input.checked = dayValue !== null && normalized.includes(dayValue);
        input.disabled = !isAdmin;
      });
    }

    function getSelectedRecurrenceDaysFromInputs(dayInputs) {
      if (!dayInputs.length) return normalizeDayList(WEEKDAY_ORDER.slice());
      const values = [];
      dayInputs.forEach(input => {
        if (!input.checked) return;
        const dayValue = normalizeDayIndex(input.value);
        if (dayValue !== null) values.push(dayValue);
      });
      return normalizeDayList(values.length ? values : WEEKDAY_ORDER.slice());
    }

    function readRecurrenceConfigFromForm(habit, { modeRadios, intervalSelect, startDateInput, endDateInput, dayInputs }) {
      const mode = getSelectedRecurrenceMode(modeRadios);
      const intervalWeeks = mode === 'interval'
        ? Math.max(2, Math.min(4, Number(intervalSelect?.value) || 2))
        : 1;
      const startDateValue = startDateInput
        ? toIsoDateString(parseDateInput(startDateInput.value) || curDate())
        : toIsoDateString(curDate());
      const endDateValue = endDateInput
        ? toIsoDateString(endDateInput.value)
        : '';
      const weekDays = getSelectedRecurrenceDaysFromInputs(dayInputs);
      return normalizeRepeatConfig(habit, {
        unit: 'week',
        interval: intervalWeeks,
        startDate: startDateValue,
        endDate: endDateValue,
        weekDays
      });
    }


    function getSlotsFromFrequency(habit) {
      const freqValue = Number(habit?.frequency ?? 3);
      if (freqValue <= 0) return 1;
      if (freqValue < 1) return 1;
      return Math.max(1, Math.min(7, Math.round(freqValue)));
    }

    function shouldOccurOnDate(habit, date = curDate()) {
      const config = getHabitRepeatConfig(habit);
      if (!config) return true;
      const target = parseDateInput(date) || curDate();
      const start = parseDateInput(config.startDate);
      if (!start || target < start) return false;
      if (config.unit === 'day') {
        const diff = daysBetween(start, target);
        return diff >= 0 && diff % config.interval === 0;
      }
      if (config.unit === 'week') {
        const diffWeeks = weeksBetween(start, target);
        const day = target.getDay();
        const hasDay = config.weekDays.includes(day);
        return diffWeeks >= 0 && hasDay && diffWeeks % config.interval === 0;
      }
      return true;
    }

    function getWeekStart(date = new Date()) {
      const copy = new Date(date);
      copy.setHours(0, 0, 0, 0);
      const diff = (copy.getDay() + 6) % 7;
      copy.setDate(copy.getDate() - diff);
      return copy;
    }

    function buildHabitPayload(space, source = {}, overrides = {}) {
      const baseHabit = { ...source, repeatConfig: source.repeatConfig || {} };
      const repeatConfig = normalizeRepeatConfig(baseHabit, overrides.repeatConfig || {});
      const freqValue = overrides.frequency ?? repeatConfig.interval ?? source.frequency ?? 1;
      const defaultMode = isPersonalSpaceType(space) ? { type: 'libre', n: 2 } : { type: 'commun', n: 2 };
      return {
        id: overrides.id || source.id,
        titre: overrides.titre || source.titre || source.title || '',
        emoji: overrides.emoji || source.emoji || 'ğŸŒ±',
        desc: (overrides.desc ?? source.desc ?? source.note ?? '').trim(),
        note: source.note || overrides.note || '',
        frequency: String(freqValue),
        contexts: overrides.contexts || source.contexts || [],
        needs: overrides.needs || source.needs || [],
        spaces: overrides.spaces || source.spaces || [],
        mode: overrides.mode || source.mode || defaultMode,
        repeatConfig,
        addedAt: overrides.addedAt || getWeekStart(new Date())
      };
    }
    function refreshLibraryTags() {
      const contexts = new Set();
      const needs = new Set();
      LIBRARY_HABITS.forEach(habit => {
        (habit.contexts || []).forEach(c => contexts.add(c));
        (habit.needs || []).forEach(n => needs.add(n));
      });
      LIBRARY_CONTEXTS.length = 0;
      LIBRARY_CONTEXTS.push(...Array.from(contexts).sort((a, b) => a.localeCompare(b, 'fr')));
      LIBRARY_NEEDS.length = 0;
      LIBRARY_NEEDS.push(...Array.from(needs).sort((a, b) => a.localeCompare(b, 'fr')));
    }
    function m2txt(m) {
      if (!m) return '0h00';
      const h = Math.floor(m / 60), mn = m % 60;
      if (h) {
        return mn ? `${h}h${String(mn).padStart(2, '0')}` : `${h}h`;
      }
      return `0h${String(mn).padStart(2, '0')}`;
    }
    function m2txtShort(m) {
      if (!m) return '0m';
      const h = (m / 60) | 0, mn = m % 60;
      if (h) {
        return mn ? `${h}h${String(mn).padStart(2, '0')}` : `${h}h`;
      }
      return `${mn}m`;
    }
    function oneLiner(s) { return (s || '').replace(/\s*\n\s*/g, ' Â· ') }

    /* Global */
    let spaceId = 'D0PWE3', userName = 'Moi', dayOff = 0;
    let profilePeriod = '30d', activeProfileName = null, activeProfileEmail = null, profileReturnView = 'detail';

    /* Spaces */
    const SPACES = {};
    const SPACE_ACTIVITIES = {};
    const INVITE_CACHE = {};
    const STORAGE_USER_PROFILE = 'habitu-user-profile';
    const STORAGE_GUEST_SPACES = 'habitu-guest-spaces';
    const STORAGE_PROFILE_SETUP_KEY = 'habitu-profile-setup-done';
    const GARDEN_TYPES = [
      { emoji: 'ğŸ ', label: 'ğŸ  Colocation', type: 'group', desc: 'Petites routines partagÃ©es Ã  la maison.' },
      { emoji: 'ğŸŒ', label: 'ğŸŒ Famille', type: 'group', desc: 'Rituels doux pour toute la famille.' },
      { emoji: 'ğŸ›ï¸', label: 'ğŸ›ï¸ Association', type: 'group', desc: 'Moments dâ€™Ã©quipe rÃ©guliers.' },
      { emoji: 'ğŸ«', label: 'Ã‰cole / Classe', type: 'group', desc: 'Rituels pÃ©dagogiques simples.' },
      { emoji: 'ğŸ¢', label: 'ğŸ¢ Bureau', type: 'group', desc: 'Rituels collaboratifs pro.' }
    ];
    let allowedSpaces = [];
    let currentProfile = loadStoredProfile();
    let guestSpaces = loadGuestSpaces();
    let pendingInviteToken = new URLSearchParams(window.location.search).get('invite');
    let pendingInviteInfo = null;
    const HABITU_FIREBASE_DB = window.HABITU_FIREBASE_DB;
    const ACTIVITY_BUFFER_MS = 3e3;
    const ACTIVITY_SYNC_INTERVAL_MS = 24 * 60 * 60 * 1000;
    const ACTIVITY_SYNC_STORAGE_KEY = 'habitu-last-activity-sync';
    const IS_LOCAL_FILE_URL = window.location.protocol === 'file:';
    const STORAGE_ALLOW_FIRESTORE_FROM_LOCAL = 'habitu-allow-firestore-local';
    function isFirestoreAllowedLocally() {
      try {
        if (!IS_LOCAL_FILE_URL) return true;
        if (!window.localStorage) return false;
        const stored = window.localStorage.getItem(STORAGE_ALLOW_FIRESTORE_FROM_LOCAL);
        if (stored === '0') return false;
        if (stored === '1') return true;
      } catch (err) {
        console.warn('isFirestoreAllowedLocally', err);
      }
      return false;
    }
    const FIRESTORE_ENABLED_LOCALLY = isFirestoreAllowedLocally();
    function canWriteFirestore() {
      return Boolean(HABITU_FIREBASE_DB && (!IS_LOCAL_FILE_URL || FIRESTORE_ENABLED_LOCALLY));
    }
    const PROFILE_MODE_INFO = {
      local: {
        label: 'ğŸ”’ PrivÃ©',
        summary: 'DonnÃ©es en locale. Pas de sauvegarde ni de jardin partagÃ©.'
      },
      minimal: {
        label: 'ğŸ”— PartagÃ©',
        summary: 'DonnÃ©es de compte en ligne. Pas de classement.'
      },
      complet: {
        label: 'ğŸŒ Public',
        summary: 'DonnÃ©es complÃ¨tes synchronisÃ©es. Profil et classement visibles'
      }
    };
    const DEFAULT_PROFILE_MODE = 'complet';
    function getProfileMode(profile = currentProfile) {
      const candidate = (profile?.profileMode || '').toString().toLowerCase();
      if (PROFILE_MODE_INFO[candidate]) {
        return candidate;
      }
      return DEFAULT_PROFILE_MODE;
    }
    function isProfileModeLocal(profile = currentProfile) {
      return getProfileMode(profile) === 'local';
    }
    function isProfileModeMinimal(profile = currentProfile) {
      return getProfileMode(profile) === 'minimal';
    }
    function isProfileModeComplet(profile = currentProfile) {
      return getProfileMode(profile) === 'complet';
    }
    function shouldWriteToFirestore(profile = currentProfile) {
      return Boolean(canWriteFirestore() && !isProfileModeLocal(profile));
    }
    function shouldSyncActivities(profile = currentProfile) {
      return Boolean(shouldWriteToFirestore(profile) && isProfileModeComplet(profile));
    }
    function getLastActivitySyncTime() {
      if (typeof window === 'undefined' || !window.localStorage) return null;
      try {
        const stored = window.localStorage.getItem(ACTIVITY_SYNC_STORAGE_KEY);
        return stored ? Number(stored) : null;
      } catch (err) {
        console.warn('getLastActivitySyncTime', err);
        return null;
      }
    }
    function setLastActivitySyncTime(timestamp = Date.now()) {
      if (typeof window === 'undefined' || !window.localStorage) return;
      try {
        window.localStorage.setItem(ACTIVITY_SYNC_STORAGE_KEY, String(timestamp));
      } catch (err) {
        console.warn('setLastActivitySyncTime', err);
      }
    }
    function canSyncActivitiesNow() {
      if (!shouldSyncActivities()) return false;
      const lastSync = getLastActivitySyncTime();
      if (!lastSync) return true;
      return Date.now() - lastSync >= ACTIVITY_SYNC_INTERVAL_MS;
    }
    function shouldRenderRankings() {
      return isProfileModeComplet();
    }
    function shouldShowGardenerBadges() {
      return !isProfileModeLocal();
    }
    async function updateProfileMode(mode = DEFAULT_PROFILE_MODE) {
      const normalized = PROFILE_MODE_INFO[mode] ? mode : DEFAULT_PROFILE_MODE;
      const updated = { ...(currentProfile || {}), profileMode: normalized };
      persistProfile(updated);
      if (shouldWriteToFirestore(updated)) {
        await persistUserProfile({
          uid: updated.uid,
          email: updated.email,
          name: updated.name,
          pseudo: updated.pseudo,
          tipsDisplayMode: updated.tipsDisplayMode,
          pinnedHabits: updated.pinnedHabits,
          postponedHabits: updated.postponedHabits,
          forgottenHabits: updated.forgottenHabits,
          showFriendBadges: updated.showFriendBadges,
          profileMode: normalized
        });
      }
      renderCards();
      renderSpaceRank();
      renderHabitGardeners();
    }
    const activityQueue = new Map();
    const SESSION_COOKIE_NAME = 'habitube-session';
    const SESSION_COOKIE_MAX_AGE = 365 * 24 * 60 * 60 * 1000;
    function loadStoredProfile() { try { return JSON.parse(localStorage.getItem(STORAGE_USER_PROFILE) || 'null') } catch (e) { return null } }
    function loadGuestSpaces() {
      try {
        const stored = JSON.parse(localStorage.getItem(STORAGE_GUEST_SPACES) || '[]');
        return new Set(Array.isArray(stored) ? stored.filter(Boolean) : []);
      } catch (e) {
        return new Set();
      }
    }
    function persistGuestSpaces() {
      try {
        localStorage.setItem(STORAGE_GUEST_SPACES, JSON.stringify(Array.from(guestSpaces)));
      } catch (e) {
        console.warn('persistGuestSpaces', e);
      }
    }
    function addGuestSpace(spaceId) {
      if (!spaceId) return;
      guestSpaces.add(spaceId);
      persistGuestSpaces();
    }
    function clearGuestSpaces() {
      if (guestSpaces.size === 0) return;
      guestSpaces.clear();
      persistGuestSpaces();
    }
    function setSessionCookie() {
      const expires = new Date(Date.now() + SESSION_COOKIE_MAX_AGE).toUTCString();
      document.cookie = `${SESSION_COOKIE_NAME}=1; expires=${expires}; path=/; SameSite=Lax`;
    }
    function clearSessionCookie() {
      document.cookie = `${SESSION_COOKIE_NAME}=; expires=${new Date(0).toUTCString()}; path=/; SameSite=Lax`;
    }
    function persistProfile(profile) {
      if (!profile) {
        safeStorageSet(STORAGE_PROFILE_SETUP_KEY, '0');
        localStorage.removeItem(STORAGE_USER_PROFILE);
        currentProfile = null;
        clearSessionCookie();
        updateAddModalOptions();
        return;
      }
      const nextProfile = { ...(currentProfile || {}), ...profile };
      if (!PROFILE_MODE_INFO[nextProfile.profileMode]) {
        nextProfile.profileMode = DEFAULT_PROFILE_MODE;
      }
      localStorage.setItem(STORAGE_USER_PROFILE, JSON.stringify(nextProfile));
      currentProfile = nextProfile;
      setSessionCookie();
      updateAddModalOptions();
    }

    function clearObject(obj) { Object.keys(obj).forEach(k => delete obj[k]); }
    function clearLocalState() {
      clearObject(HABIT_DESC);
      clearObject(HABIT_TITLE_CUSTOM);
      clearObject(SPACE_DESC_TXT);
      clearObject(BASE_MINUTES);
      clearObject(HABIT_MODE);
      clearObject(LOCKED_COMMUN);
      clearObject(LOCKED_BY);
      clearObject(DONE_SETS);
      clearObject(HAS_DESC);
      DELETED_HABITS.clear();
      allowedSpaces = [];
      Object.keys(SPACE_ACTIVITIES).forEach(k => delete SPACE_ACTIVITIES[k]);
      Object.keys(INVITE_CACHE).forEach(k => delete INVITE_CACHE[k]);
      Object.keys(SPACES).forEach(k => delete SPACES[k]);
      spaceId = null;
      spacesInitialized = false;
    }
    function normalizeEmail(email) {
      return String(email || '').trim().toLowerCase();
    }
    function buildMemberInfo(members) {
      const emails = new Set();
      const userIds = new Set();
      const idByEmail = {};
      if (!Array.isArray(members)) {
        return { emails: [], userIds: [], idByEmail };
      }
      members.forEach(member => {
        if (!member) return;
        if (typeof member === 'string') {
          const candidate = member.trim();
          if (!candidate) return;
          if (candidate.includes('@')) {
            const email = normalizeEmail(candidate);
            if (email) emails.add(email);
          } else {
            userIds.add(candidate);
          }
          return;
        }
        if (typeof member === 'object') {
          const candidate = String(member.email || member.value || '').trim();
          let normalizedEmail = '';
          if (candidate.includes('@')) {
            normalizedEmail = normalizeEmail(candidate);
            if (normalizedEmail) {
              emails.add(normalizedEmail);
            } else {
              normalizedEmail = '';
            }
          } else if (candidate) {
            userIds.add(candidate);
          }
          const resolvedId = String(member.uid || member.id || member.userId || member.value || '').trim();
          if (resolvedId && !resolvedId.includes('@')) {
            userIds.add(resolvedId);
            if (normalizedEmail) {
              idByEmail[normalizedEmail] = resolvedId;
            }
          }
        }
      });
      return { emails: Array.from(emails), userIds: Array.from(userIds), idByEmail };
    }
    function normalizeMemberKey(value) {
      if (!value) return '';
      const trimmed = String(value).trim();
      if (!trimmed) return '';
      if (trimmed.includes('@')) {
        return normalizeEmail(trimmed);
      }
      return trimmed;
    }
    function ensureSpaceMemberSettings(space) {
      if (!space) return {};
      if (!space.memberSettings || typeof space.memberSettings !== 'object') {
        space.memberSettings = {};
      }
      return space.memberSettings;
    }
    function getSpaceMemberLabel(space, memberKey) {
      const key = normalizeMemberKey(memberKey);
      if (!key) return '';
      const settings = ensureSpaceMemberSettings(space);
      const custom = settings[key];
      if (custom?.name) return custom.name;
      if (key.includes('@')) {
        return key.split('@')[0];
      }
      return '';
    }
    function getCurrentSpaceMemberKey(space) {
      if (!space) return '';
      const emailKey = normalizeMemberKey(currentProfile?.email);
      if (emailKey && (space.members || []).some(member => normalizeMemberKey(member) === emailKey)) {
        return emailKey;
      }
      const uidKey = normalizeMemberKey(currentProfile?.uid);
      if (uidKey && (space.members || []).some(member => normalizeMemberKey(member) === uidKey)) {
        return uidKey;
      }
      return '';
    }
    function isCurrentMemberKey(key) {
      const normalized = normalizeMemberKey(key);
      if (!normalized) return false;
      const emailKey = normalizeMemberKey(currentProfile?.email);
      if (emailKey && emailKey === normalized) return true;
      const uidKey = normalizeMemberKey(currentProfile?.uid);
      if (uidKey && uidKey === normalized) return true;
      return false;
    }
    async function updateSpaceMemberName(spaceId, memberKey, name, { persist = true } = {}) {
      if (!spaceId || !memberKey) return;
      const sp = SPACES[spaceId];
      if (!sp) return;
      const normalized = normalizeMemberKey(memberKey);
      if (!normalized) return;
      const settings = ensureSpaceMemberSettings(sp);
      const finalName = (name || '').trim();
      if (finalName) {
        settings[normalized] = { name: finalName };
      } else {
        delete settings[normalized];
      }
      if (isCurrentMemberKey(normalized)) {
        setLastMemberName(finalName);
      }
      if (persist) {
        await persistSpaceDoc(spaceId, { memberSettings: settings });
      }
    }
    function sanitizeSpaceMembers(members) {
      const { emails, userIds } = buildMemberInfo(members);
      if (!userIds.length) return emails;
      return [...emails, ...userIds];
    }
    function isMemberInSpace(spaceIdArg, memberKey) {
      if (!spaceIdArg || !memberKey) return false;
      const space = SPACES[spaceIdArg];
      if (!space) return false;
      const normalizedKey = normalizeMemberKey(memberKey);
      if (!normalizedKey) return false;
      const normalizedMembers = new Set(sanitizeSpaceMembers(space.members));
      return normalizedMembers.has(normalizedKey);
    }
    function resolveMemberUserId(spaceIdArg, email) {
      if (!spaceIdArg || !email) return null;
      const normalized = normalizeEmail(email);
      if (!normalized) return null;
      const sp = SPACES[spaceIdArg];
      if (sp?.memberIdByEmail?.[normalized]) {
        return sp.memberIdByEmail[normalized];
      }
      const activities = SPACE_ACTIVITIES[spaceIdArg] || [];
      for (const activity of activities) {
        if (normalizeEmail(activity.userEmail || '') === normalized && activity.userId) {
          return activity.userId;
        }
      }
      return null;
    }
    async function refreshOwnedSpaces(profile) {
      const email = profile?.email;
      const uid = profile?.uid;
      if (!email && !uid) return [];
      try {
        const spaces = await fetchSpacesForUser(profile);
        spaces.forEach(space => {
          const existing = SPACES[space.id] || {};
          const memberSettings = space.memberSettings || existing.memberSettings || {};
          SPACES[space.id] = { ...existing, ...space, members: space.members || [], memberSettings, ch: space.ch || [] };
        });
        const collected = spaces.map(space => space.id);
        allowedSpaces = [...new Set([...allowedSpaces, ...collected])];
        return spaces;
      } catch (err) {
        console.warn('refreshOwnedSpaces', err);
        return [];
      }
    }
    function isProfileSpaceOwner(space, profile) {
      if (!space || !profile) return false;
      return Boolean(space.ownerId && profile.uid && space.ownerId === profile.uid);
    }
    function isPersonalSpaceType(space) {
      const value = (space?.type || '').toString().toLowerCase();
      return value === 'private' || value === 'individual';
    }
    function getSpaceOwnerLabel(space) {
      if (!space) return '';
      if (space.ownerId && currentProfile?.uid && space.ownerId === currentProfile.uid) {
        return currentProfile.name || userName || 'Moi';
      }
      const ownerLabel = getSpaceMemberLabel(space, space.ownerId);
      if (ownerLabel) return ownerLabel;
      return 'Un jardinier';
    }
    function countOwnedGardens(profile) {
      if (currentProfile?.guest) {
        return guestSpaces.size;
      }
      if (!profile) return 0;
      return Object.values(SPACES).filter(space => isProfileSpaceOwner(space, profile)).length;
    }
    function displayNameFromEmail(email) {
      const normalized = normalizeEmail(email);
      if (!normalized) return '';
      if (currentProfile && normalizeEmail(currentProfile.email) === normalized) {
        return currentProfile.name || 'Moi';
      }
      const candidate = (email || '').trim();
      return candidate.includes('@') ? candidate.split('@')[0] : candidate;
    }
    function getCurrentOwnerLabel() {
      const candidate = (userName || '').trim();
      return candidate || 'Moi';
    }
    function normalizeOwnerLabel(label) {
      return ((label || '').trim() || '').toLowerCase();
    }
    function isCurrentUserLabel(label) {
      const normalized = normalizeOwnerLabel(label);
      if (!normalized) return false;
      const canonical = normalizeOwnerLabel(getCurrentOwnerLabel());
      return normalized === canonical || normalized === 'moi';
    }
    function timestampToDate(value) {
      if (!value) return null;
      if (value?.toDate) return value.toDate();
      return new Date(value);
    }
    function dayKeyFromDate(date) {
      return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
    }
    function getEventDayKey(event) {
      if (!event) return '';
      if (event.activityDate) {
        return event.activityDate;
      }
      const recordedAt = timestampToDate(event.recordedAt);
      if (!recordedAt) return '';
      return dayKeyFromDate(recordedAt);
    }
    function upsertLocalHabitActivity(event) {
      if (!event || !event.spaceId || !event.habitId) return;
      const owner = event.owner || getOwnerNameFromEvent(event);
      if (!owner) return;
      const recordedAt = timestampToDate(event.recordedAt) || new Date();
      const dayKey = event.activityDate || dayKeyFromDate(recordedAt);
      const key = `${owner}:${event.habitId}:${dayKey}`;
      const bucket = SPACE_ACTIVITIES[event.spaceId] || [];
      const idx = bucket.findIndex(ev => {
        const existingOwner = ev.owner || getOwnerNameFromEvent(ev);
        if (!existingOwner) return false;
        const existingDayKey = ev.activityDate || dayKeyFromDate(timestampToDate(ev.recordedAt) || new Date(0));
        return `${existingOwner}:${ev.habitId}:${existingDayKey}` === key;
      });
      const stored = { ...event, recordedAt };
      if (idx === -1) {
        bucket.push(stored);
      } else {
        const prev = timestampToDate(bucket[idx].recordedAt) || new Date(0);
        if (recordedAt >= prev) {
          bucket[idx] = stored;
        }
      }
      SPACE_ACTIVITIES[event.spaceId] = bucket;
    }
    function computeActorCountsForEvent(event) {
      if (!event || !event.spaceId || !event.habitId) {
        return { window: 0, total: 0 };
      }
      const ownerLabel = event.owner || getOwnerNameFromEvent(event);
      if (!ownerLabel) {
        return { window: 0, total: 0 };
      }
      const normalizedOwner = normalizeOwnerLabel(ownerLabel);
      if (!normalizedOwner) {
        return { window: 0, total: 0 };
      }
      const sinceDate = addDays(curDate(), -DEFAULT_GARDENER_WINDOW_DAYS);
      const events = getSpaceEvents(event.spaceId);
      const windowDays = new Set();
      const totalDays = new Set();
      events.forEach(ev => {
        if (String(ev.habitId) !== String(event.habitId)) return;
        const owner = getOwnerNameFromEvent(ev);
        if (normalizeOwnerLabel(owner) !== normalizedOwner) return;
        const dayKey = getEventDayKey(ev);
        if (!dayKey) return;
        totalDays.add(dayKey);
        const recordedAt = timestampToDate(ev.recordedAt);
        if (!recordedAt) return;
        if (!sinceDate || recordedAt >= sinceDate) {
          windowDays.add(dayKey);
        }
      });
      return { window: windowDays.size, total: totalDays.size };
    }
    function isCurrentSpaceAdmin() {
      const sp = getSpace();
      return !!sp && isProfileSpaceOwner(sp, currentProfile);
    }
    function getEditorRights(space) {
      const mode = (space?.editorRights || 'admin').toString().toLowerCase();
      return mode === 'registered' ? 'registered' : 'admin';
    }
    function hasEditPermission() {
      const sp = getSpace();
      if (!sp) return false;
      const rights = getEditorRights(sp);
      if (rights === 'registered') {
        return !!currentProfile?.email;
      }
      return isCurrentSpaceAdmin();
    }
    function requireAdmin(action = 'modifier') {
      if (!hasEditPermission()) {
        alert(`Seuls les jardiniers autorisÃ©s peuvent ${action}.`);
        return false;
      }
      return true;
    }
    function persistUserProfile(profile) {
      if (!shouldWriteToFirestore(profile) || !profile?.uid) return Promise.resolve();
      const payload = {
        name: profile.name,
        email: profile.email,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      if (profile.tipsDisplayMode !== undefined) {
        payload.tipsDisplayMode = profile.tipsDisplayMode;
      }
      if (profile.pinnedHabits !== undefined) {
        payload.pinnedHabits = normalizeHabitArray(profile.pinnedHabits);
      }
      if (profile.postponedHabits !== undefined) {
        payload.postponedHabits = normalizePostponedMap(profile.postponedHabits);
      }
      if (profile.forgottenHabits !== undefined) {
        payload.forgottenHabits = normalizeHabitArray(profile.forgottenHabits);
      }
      if (profile.showFriendBadges !== undefined) {
        payload.showFriendBadges = profile.showFriendBadges;
      }
      if (profile.pseudo !== undefined) {
        payload.pseudo = profile.pseudo;
        const normalizedPseudo = sanitizePseudo(profile.pseudo);
        if (normalizedPseudo) {
          payload.pseudoNormalized = normalizedPseudo.toLowerCase();
        }
      }
      if (profile.profileMode !== undefined) {
        payload.profileMode = profile.profileMode;
      }
      return HABITU_FIREBASE_DB.collection('users').doc(profile.uid)
        .set(payload, { merge: true })
        .catch(e => console.warn('persistUserProfile', e));
    }

    async function loadRemoteUserProfile(uid) {
      if (!HABITU_FIREBASE_DB || !uid) return null;
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('users').doc(uid).get();
        if (!snapshot.exists) return null;
        return snapshot.data() || null;
      } catch (err) {
        console.warn('loadRemoteUserProfile', err);
        return null;
      }
    }

    async function updateUserTipsDisplayMode(mode) {
      if (!currentProfile) return;
      const normalized = ['auto', 'oui', 'non'].includes(mode) ? mode : 'auto';
      const updated = { ...currentProfile, tipsDisplayMode: normalized };
      persistProfile(updated);
      await persistUserProfile({
        uid: updated.uid,
        email: updated.email,
        name: updated.name,
        tipsDisplayMode: normalized,
        pinnedHabits: updated.pinnedHabits,
        postponedHabits: updated.postponedHabits,
        showFriendBadges: updated.showFriendBadges
      });
    }
    async function updateUserPseudo(newPseudo) {
      if (!currentProfile) return;
      const normalized = sanitizePseudo(newPseudo);
      if (!normalized) return;
      const updated = { ...currentProfile, pseudo: normalized };
      persistProfile(updated);
      await persistUserProfile({
        uid: updated.uid,
        email: updated.email,
        name: updated.name,
        pseudo: normalized,
        tipsDisplayMode: updated.tipsDisplayMode,
        pinnedHabits: updated.pinnedHabits,
        postponedHabits: updated.postponedHabits,
        forgottenHabits: updated.forgottenHabits,
        showFriendBadges: updated.showFriendBadges
      });
    }
    function persistSpaceDoc(spaceId, data = {}) {
      if (!shouldWriteToFirestore() || !spaceId) return Promise.resolve();
      const space = SPACES[spaceId] || {};
      const members = sanitizeSpaceMembers(space.members);
      const memberSettings = ensureSpaceMemberSettings(space);
      const payload = {
        ...space,
        ...data,
        ...(space.ownerId ? { ownerId: space.ownerId } : {}),
        memberSettings,
        members,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      return HABITU_FIREBASE_DB.collection('spaces').doc(spaceId).set(payload, { merge: true }).catch(e => console.warn('persistSpaceDoc', e));
    }

    function persistHabit(spaceId, habitData) {
      if (!shouldWriteToFirestore() || !spaceId || !habitData?.id) return Promise.resolve();
      habitData.repeatConfig = normalizeRepeatConfig(habitData, habitData.repeatConfig || {});
      ensureHabitMetadata(habitData);
      const habitId = String(habitData.id);
      return HABITU_FIREBASE_DB.collection('spaces').doc(spaceId).collection('habits').doc(habitId)
        .set({ ...habitData, id: habitId, spaceId, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true })
        .then(() => {
          markFirstHabitCreated();
        })
        .catch(e => console.warn('persistHabit', e));
    }
    function persistInviteDoc(token, payload) {
      if (!shouldWriteToFirestore() || !token) return Promise.resolve();
      const ownerId = payload.ownerId || currentProfile?.uid || null;
      const ownerName = payload.ownerName || currentProfile?.name || userName || 'Un jardinier';
      return HABITU_FIREBASE_DB.collection('invites').doc(token)
        .set({ ...payload, ownerId, ownerName, token, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true })
        .catch(e => console.warn('persistInvite', e));
    }
    function deleteInviteDoc(token) {
      if (!shouldWriteToFirestore() || !token) return Promise.resolve();
      delete INVITE_CACHE[token];
      return HABITU_FIREBASE_DB.collection('invites').doc(token).delete().catch(e => console.warn('deleteInvite', e));
    }
    function sendActivityToServer(payload) {
      if (!canSyncActivitiesNow()) {
        console.info('Skipping Firestore activity log because sync window has not elapsed');
        return Promise.resolve();
      }
      return HABITU_FIREBASE_DB.collection('activities').add(payload)
        .then((docRef) => {
          setLastActivitySyncTime();
          return docRef;
        })
        .catch(e => {
          console.warn('sendActivity', e);
          return Promise.reject(e);
        });
    }
    function scheduleHabitActivity(habitId, payload) {
      if (!habitId || !payload) return;
      const key = `${habitId}:${payload.type}`;
      if (activityQueue.has(key)) {
        clearTimeout(activityQueue.get(key));
      }
      const actorName = currentProfile?.name || 'Moi';
      const ownerLabel = (payload.owner || getOwnerNameFromEvent(payload) || getCurrentOwnerLabel()).trim();
      const currentSpaceType = getSpace()?.type || null;
      const targetRecordedAt = payload.recordedAt ? timestampToDate(payload.recordedAt) : null;
      const localRecordedAt = targetRecordedAt || new Date();
      const activityDate = dayKeyFromDate(localRecordedAt);
      const loggedAtLocal = new Date();
      const actorPseudo = currentProfile?.pseudo || '';
      const baseEvent = {
        ...payload,
        habitId,
        spaceId,
        spaceType: currentSpaceType,
        userEmail: currentProfile?.email || null,
        userId: currentProfile?.uid || null,
        actorName,
        owner: ownerLabel,
        actorPseudo,
        activityDate
      };
      const serverRecordedAt = targetRecordedAt
        ? firebase.firestore.Timestamp.fromDate(targetRecordedAt)
        : firebase.firestore.FieldValue.serverTimestamp();
      const eventData = {
        ...baseEvent,
        recordedAt: serverRecordedAt,
        loggedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      const localEvent = {
        ...baseEvent,
        recordedAt: localRecordedAt,
        loggedAt: loggedAtLocal
      };
      if (payload.type === 'realization') {
        upsertLocalHabitActivity(localEvent);
        const counts = computeActorCountsForEvent(localEvent);
        localEvent.actor30DaysCount = counts.window;
        localEvent.actorTotalCount = counts.total;
        eventData.actor30DaysCount = counts.window;
        eventData.actorTotalCount = counts.total;
        upsertLocalHabitActivity(localEvent);
      }
      if (!shouldSyncActivities()) {
        if (IS_LOCAL_FILE_URL) {
          console.warn('Skipping Firestore activity log while running from file:// or profile settings');
        }
        return;
      }
      const timer = setTimeout(() => {
        sendActivityToServer(eventData);
        activityQueue.delete(key);
      }, ACTIVITY_BUFFER_MS);
      activityQueue.set(key, timer);
    }
    function ensureHabitMetadata(habit) {
      if (!habit?.id) return;
      const candidateBaseMin = habit?.baseMin ?? habit?.duration;
      if (candidateBaseMin && Number.isFinite(Number(candidateBaseMin))) {
        BASE_MINUTES[habit.id] = Number(candidateBaseMin);
      } else if (!BASE_MINUTES[habit.id]) {
        BASE_MINUTES[habit.id] = DEFAULT_DURATION;
      }
      if (habit.desc || habit.note) HABIT_DESC[habit.id] = habit.desc || habit.note || '';
      if (habit.customTitle) HABIT_TITLE_CUSTOM[habit.id] = habit.customTitle;
      if (habit.mode) HABIT_MODE[habit.id] = habit.mode;
      cacheRepeatConfigFromHabit(habit);
    }
    async function fetchSpacesForUser(profile) {
      if (!HABITU_FIREBASE_DB || !profile) return [];
      const normalizedEmail = normalizeEmail(profile.email);
      const normalizedUserId = (profile.uid || '').trim();
      const snapshots = [];
      const queries = [];
      if (normalizedUserId) {
        queries.push(HABITU_FIREBASE_DB.collection('spaces').where('ownerId', '==', normalizedUserId).get());
        queries.push(HABITU_FIREBASE_DB.collection('spaces').where('members', 'array-contains', normalizedUserId).get());
      }
      if (normalizedEmail) {
        queries.push(HABITU_FIREBASE_DB.collection('spaces').where('members', 'array-contains', normalizedEmail).get());
      }
      for (const queryPromise of queries) {
        try {
          const snapshot = await queryPromise;
          snapshots.push(snapshot);
        } catch (err) {
          console.warn('fetchSpacesForUser query', err);
        }
      }
      if (!snapshots.length) return [];
      const spacesById = new Map();
      const addFromSnapshot = (snapshot) => {
        if (!snapshot) return;
        snapshot.forEach(doc => {
          const raw = doc.data() || {};
          const memberSettings = raw.memberSettings || {};
          const data = { id: doc.id, ...raw, createdAt: timestampToDate(raw.createdAt) };
          const { emails: memberEmails, userIds, idByEmail } = buildMemberInfo(raw.members);
          const sanitizedMembers = [...memberEmails, ...userIds];
          spacesById.set(doc.id, {
            ...data,
            members: sanitizedMembers,
            memberIdByEmail: idByEmail,
            memberSettings
          });
        });
      };
      snapshots.forEach(addFromSnapshot);
      return Array.from(spacesById.values());
    }
    async function fetchPersonalSpaceForOwner(ownerId) {
      if (!HABITU_FIREBASE_DB || !ownerId) return null;
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('spaces')
          .where('ownerId', '==', ownerId)
          .where('type', '==', 'individual')
          .limit(1)
          .get();
        if (!snapshot || snapshot.empty) return null;
        const doc = snapshot.docs[0];
        const raw = doc.data() || {};
        const members = Array.isArray(raw.members) ? raw.members : [];
        return {
          id: doc.id,
          ...raw,
          members,
          memberIdByEmail: raw.memberIdByEmail || {},
          createdAt: timestampToDate(raw.createdAt)
        };
      } catch (err) {
        console.warn('fetchPersonalSpaceForOwner', err);
        return null;
      }
    }
    async function loadHabitsForSpace(spaceId) {
      if (!HABITU_FIREBASE_DB || !spaceId) return [];
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('spaces').doc(spaceId).collection('habits').get();
        const habits = snapshot.docs.map(doc => {
          const habit = { id: doc.id, ...doc.data() };
          if (habit.addedAt) habit.addedAt = timestampToDate(habit.addedAt);
          return habit;
        });
        habits.forEach(habit => {
          ensureHabitMetadata(habit);
          if (habit.deleted) {
            DELETED_HABITS.add(habit.id);
          }
        });
        const visibleHabits = habits.filter(habit => !habit.deleted);
        if (visibleHabits.length > 0) {
          markFirstHabitCreated();
        }
        SPACES[spaceId] = { ...(SPACES[spaceId] || {}), ch: visibleHabits };
        return visibleHabits;
      } catch (err) {
        console.warn('loadHabitsForSpace', err);
        return (SPACES[spaceId]?.ch || []).filter(habit => habit && !habit.deleted);
      }
    }
    async function loadActivitiesForSpace(spaceId, days = 120) {
      if (!HABITU_FIREBASE_DB || !spaceId) return [];
      const since = new Date();
      since.setDate(since.getDate() - days);
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('activities')
          .where('spaceId', '==', spaceId)
          .where('recordedAt', '>=', since)
          .orderBy('recordedAt', 'desc')
          .get();
        const events = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        SPACE_ACTIVITIES[spaceId] = events;
        return events;
      } catch (err) {
        console.warn('loadActivitiesForSpace', err);
        SPACE_ACTIVITIES[spaceId] = SPACE_ACTIVITIES[spaceId] || [];
        return SPACE_ACTIVITIES[spaceId];
      }
    }
    function getAllPersonalSpaceIds() {
      return Object.values(SPACES)
        .filter(space => space && space.id && isPersonalSpaceType(space))
        .map(space => space.id);
    }
    async function loadPersonalSpaceActivities(days = DEFAULT_GARDENER_WINDOW_DAYS) {
      const ids = getAllPersonalSpaceIds();
      await Promise.all(ids.map(id => loadActivitiesForSpace(id, days)));
      const merged = getMergedPersonalSpaceRecords(days);
      PERSONAL_ACTIVITY_CACHE = merged;
      PERSONAL_ACTIVITY_CACHE_DAYS = days;
      PERSONAL_ACTIVITY_LAST_REFRESH = Date.now();
      return merged;
    }
    async function fetchSpaceDoc(spaceId) {
      if (!HABITU_FIREBASE_DB || !spaceId) return null;
      try {
        const doc = await HABITU_FIREBASE_DB.collection('spaces').doc(spaceId).get();
        if (!doc.exists) return null;
        const raw = doc.data() || {};
        const members = Array.isArray(raw.members) ? raw.members : [];
        return {
          id: doc.id,
          ...raw,
          members,
          memberIdByEmail: raw.memberIdByEmail || {},
          createdAt: timestampToDate(raw.createdAt)
        };
      } catch (err) {
        console.warn('fetchSpaceDoc', err);
        return null;
      }
    }
    async function refreshGuestSpaces() {
      if (!guestSpaces.size || !HABITU_FIREBASE_DB) {
        spacesInitialized = true;
        return [];
      }
      const spaceIds = Array.from(guestSpaces);
      const docs = await Promise.all(spaceIds.map(id => fetchSpaceDoc(id)));
      const spaces = docs.filter(Boolean);
      if (!spaces.length) {
        spacesInitialized = true;
        return [];
      }
      const validIds = spaces.map(space => space.id);
      spaces.forEach(space => {
        SPACES[space.id] = {
          ...(SPACES[space.id] || {}),
          ...space,
          members: space.members,
          memberIdByEmail: space.memberIdByEmail,
          ch: SPACES[space.id]?.ch || []
        };
      });
      allowedSpaces = [...new Set([...allowedSpaces, ...validIds])];
      await Promise.all(validIds.map(id => loadHabitsForSpace(id)));
      await Promise.all(validIds.map(id => loadActivitiesForSpace(id)));
      await Promise.all(validIds.map(id => ensureSpaceHasPseudo(id)));
      if (!spaceId && allowedSpaces.length) {
        spaceId = allowedSpaces[0];
      }
      if (spaceId && !allowedSpaces.includes(spaceId)) {
        spaceId = allowedSpaces[0] || null;
      }
      spacesInitialized = true;
      return spaces;
    }
    async function loadInvitesForOwner(ownerId) {
      if (!HABITU_FIREBASE_DB || !ownerId) return;
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('invites').where('ownerId', '==', ownerId).get();
        Object.keys(INVITE_CACHE).forEach(key => delete INVITE_CACHE[key]);
        snapshot.forEach(doc => { INVITE_CACHE[doc.id] = { token: doc.id, ...doc.data() }; });
      } catch (err) {
        console.warn('loadInvitesForOwner', err);
      }
    }
    async function refreshPendingInviteInfo() {
      if (!pendingInviteToken || !HABITU_FIREBASE_DB) {
        pendingInviteInfo = null;
        return null;
      }
      try {
        const doc = await HABITU_FIREBASE_DB.collection('invites').doc(pendingInviteToken).get();
        pendingInviteInfo = doc.exists ? { token: doc.id, ...doc.data() } : null;
      } catch (err) {
        console.warn('refreshPendingInviteInfo', err);
        pendingInviteInfo = null;
      }
      return pendingInviteInfo;
    }
    async function acceptPendingInvite(email) {
      if (!pendingInviteToken || !email) return null;
      const invite = await refreshPendingInviteInfo();
      if (!invite) return null;
      await joinSpace(invite.spaceId, email, { name: invite.invitedName });
      await deleteInviteDoc(invite.token);
      pendingInviteToken = null;
      if (window.history.replaceState) {
        const url = new URL(window.location);
        url.searchParams.delete('invite');
        window.history.replaceState({}, '', url.pathname);
      }
      pendingInviteInfo = null;
      if (INVITE_CACHE[invite.token]) {
        delete INVITE_CACHE[invite.token];
        if (typeof renderInviteList === 'function') renderInviteList();
      }
      updateAuthMessage();
      return invite;
    }
    async function joinSpace(spaceId, email, { name } = {}) {
      if (!HABITU_FIREBASE_DB || !spaceId || !email) return;
      const normalized = normalizeEmail(email);
      try {
        await HABITU_FIREBASE_DB.collection('spaces').doc(spaceId)
          .update({ members: firebase.firestore.FieldValue.arrayUnion(normalized) });
      } catch (err) {
        if (err?.code === 'not-found') {
          console.warn('joinSpace space not found', spaceId);
        } else {
          console.warn('joinSpace', err);
        }
      }
      if (SPACES[spaceId]) {
        const members = new Set(sanitizeSpaceMembers(SPACES[spaceId].members));
        members.add(normalized);
        SPACES[spaceId].members = Array.from(members);
      }
      if (name && normalized) {
        await updateSpaceMemberName(spaceId, normalized, name);
      }
    }
    async function loadLibraryData() {
      const data = Array.isArray(window.LIBRARY_JSON_DATA) ? window.LIBRARY_JSON_DATA : null;
      if (!data) {
        console.warn('loadLibraryData: no library data available');
        return;
      }
      LIBRARY_HABITS.length = 0;
      data.forEach((habit, index) => {
        const slug = slugifyTag(habit.title || habit.titre || `habitude-${index}`);
        const safeSlug = slug || `habitude-${index}`;
        const id = habit.id || `lib-${safeSlug}-${index}`;
        const descText = (habit.note || habit.desc || '').trim();
        const candidateDuration = habit.baseMin ?? habit.duration;
        const parsedDuration = Number(candidateDuration);
        const baseMinVal = Number.isFinite(parsedDuration) ? Math.max(DEFAULT_DURATION, parsedDuration) : DEFAULT_DURATION;
        LIBRARY_HABITS.push({
          id,
          ...habit,
          desc: descText,
          titre: habit.titre || habit.title || '',
          baseMin: baseMinVal
        });
      });
      refreshLibraryTags();
      refreshLoader(getLoaderMinuteSeed());
    }
    async function resetFirestoreState(profile) {
      clearLocalState();
      const email = profile?.email;
      if (!email) { return; }
      await loadLibraryData();
      const spaces = await fetchSpacesForUser(profile);
      allowedSpaces = spaces.map(space => space.id);
      spaces.forEach(space => {
        const existing = SPACES[space.id] || {};
        const memberSettings = space.memberSettings || existing.memberSettings || {};
        SPACES[space.id] = {
          ...existing,
          ...space,
          members: space.members || [],
          memberIdByEmail: space.memberIdByEmail || {},
          memberSettings,
          ch: []
        };
      });
      await Promise.all(spaces.map(space => loadHabitsForSpace(space.id)));
      await Promise.all(spaces.map(space => loadActivitiesForSpace(space.id)));
      await loadInvitesForOwner(profile.uid);
      renderInviteList();
      await Promise.all(allowedSpaces.map(id => ensureSpaceHasPseudo(id)));
      if (!spaceId && allowedSpaces.length) { spaceId = allowedSpaces[0]; }
      if (spaceId && !allowedSpaces.includes(spaceId)) { spaceId = allowedSpaces[0] || null; }
      updateInviteGardenPseudo();
      spacesInitialized = true;
      maybeTogglePrivateAdd();
    }
    const HABIT_TITLE_IS_CUSTOM = {};

    /* ===== Helpers visuels encadrÃ©s ===== */
    function applyCardClass(card, st, owner, modeType) {
      card.className = card.className.replace(/\bs0shared\b|\bs0\b|\bs1me\b|\bs1help\b|\bs1other\b|\bs2me\b|\bs2other\b/g, '').trim();
      if (st === 0) {
        if (modeType === 'commun') card.classList.add('s0shared'); else card.classList.add('s0');
      } else if (st === 1) {
        if (isCurrentUserLabel(owner)) card.classList.add('s1me');
        else card.classList.add('s1other');
      } else if (st === 2) {
        if (isCurrentUserLabel(owner)) card.classList.add('s2me');
        else card.classList.add('s2other');
      }
    }

    /* Utils cartes */
    function formatOwnerBadgeText(ownerNames) {
      const sanitized = Array.from(new Set((ownerNames || []).map(name => (name || '').trim()).filter(Boolean)));
      if (!sanitized.length) return '';
      const hasCurrentUser = sanitized.some(isCurrentUserLabel);
      const orderedNames = [];
      if (hasCurrentUser) orderedNames.push('Moi');
      sanitized.forEach(name => {
        if (!isCurrentUserLabel(name)) orderedNames.push(name);
      });
      const maxDisplay = 3;
      const displayed = orderedNames.slice(0, maxDisplay);
      const remaining = orderedNames.length - displayed.length;
      const joinNames = arr => {
        if (arr.length === 1) return arr[0];
        if (arr.length === 2) return `${arr[0]} et ${arr[1]}`;
        const last = arr[arr.length - 1];
        return `${arr.slice(0, -1).join(', ')} et ${last}`;
      };
      const baseText = remaining > 0 ? displayed.join(', ') : joinNames(displayed);
      if (remaining > 0) {
        return `${baseText} et ${remaining} autre${remaining > 1 ? 's' : ''}`;
      }
      return baseText;
    }
    function ensureOwnerBadges(badges, owners, it, btn) {
      badges.querySelectorAll('.owner-badge').forEach(el => el.remove());
      if (!shouldShowFriendBadges()) return;
      const text = formatOwnerBadgeText(Array.isArray(owners) ? owners : []);
      if (!text) return;
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'badge owner-badge';
      b.textContent = `ğŸ§‘â€ğŸŒ¾ ${text}`;
      b.addEventListener('click', (e) => {
        e.stopPropagation();
        openDetail(it.id, btn);
      });
      badges.appendChild(b);
    }

    /* Tag "Individuel" â€” supprimÃ© */
    function ensureModeTag() { /* no-op */ }

    function setupDesc(desc, hid, { tipSeed = '' } = {}) {
      const stored = HABIT_DESC[hid] || '';
      const tipInfo = pickHabitTip(hid, tipSeed);
      desc.dataset.full = stored;
      desc.dataset.short = oneLiner(stored);
      desc.dataset.has = stored.trim() ? '1' : '0';
      desc.dataset.tip = tipInfo.text || '';
      desc.dataset.tipIndex = tipInfo.index >= 0 ? String(tipInfo.index) : '';
      desc.dataset.tipCount = tipInfo.count ? String(tipInfo.count) : '';
      const descTextEl = desc.querySelector('.desc-text');
      if (descTextEl) {
        descTextEl.textContent = desc.dataset.short;
      } else {
        desc.textContent = desc.dataset.short;
      }
      desc.classList.add('hidden');
      desc.classList.remove('open');
    }

    function getTipsDisplayMode() {
      return currentProfile?.tipsDisplayMode || 'auto';
    }
    function shouldShowFriendBadges() {
      const sp = getSpace();
      if (!sp) return false;
      return !isPersonalSpaceType(sp);
    }
    function addDays(date, offset = 0) {
      const result = new Date(date || curDate());
      result.setHours(0, 0, 0, 0);
      result.setDate(result.getDate() + offset);
      return result;
    }
    function normalizeHabitArray(list) {
      if (!Array.isArray(list)) return [];
      const seen = new Set();
      return list.map(String).filter(item => {
        if (!item) return false;
        if (seen.has(item)) return false;
        seen.add(item);
        return true;
      });
    }
    function normalizePostponedMap(map) {
      if (!map || typeof map !== 'object') return {};
      const trimmed = {};
      Object.entries(map).forEach(([key, value]) => {
        if (!key) return;
        if (typeof value !== 'string') return;
        trimmed[key] = value;
      });
      return trimmed;
    }
    function getProfileHabitArray(field) {
      return normalizeHabitArray(currentProfile?.[field]);
    }
    function getPinnedHabitIds() {
      return getProfileHabitArray('pinnedHabits');
    }
    function isHabitPinned(habitId) {
      if (!habitId) return false;
      return getPinnedHabitIds().includes(String(habitId));
    }
    function getHiddenHabits() {
      return normalizeHabitArray(currentProfile?.forgottenHabits);
    }
    function isHabitHidden(habitId) {
      if (!habitId) return false;
      return getHiddenHabits().includes(String(habitId));
    }
    async function persistHabitProfileFields(fields = {}) {
      const payloadFields = {};
      let hasField = false;
      if (fields.pinnedHabits !== undefined) {
        payloadFields.pinnedHabits = normalizeHabitArray(fields.pinnedHabits);
        hasField = true;
      }
      if (fields.postponedHabits !== undefined) {
        payloadFields.postponedHabits = normalizePostponedMap(fields.postponedHabits);
        hasField = true;
      }
      if (fields.forgottenHabits !== undefined) {
        payloadFields.forgottenHabits = normalizeHabitArray(fields.forgottenHabits);
        hasField = true;
      }
      if (!hasField) return;
      const updated = { ...(currentProfile || {}), ...payloadFields };
      persistProfile(updated);
      await persistUserProfile({
        uid: updated.uid,
        email: updated.email,
        name: updated.name,
        tipsDisplayMode: updated.tipsDisplayMode,
        pinnedHabits: updated.pinnedHabits,
        postponedHabits: updated.postponedHabits,
        forgottenHabits: updated.forgottenHabits,
        showFriendBadges: updated.showFriendBadges
      });
    }

    function getDescTipSeed(baseDate = curDate()) {
      const anchor = new Date(baseDate);
      anchor.setHours(0, 0, 0, 0);
      const dateKey = `${anchor.getFullYear()}-${anchor.getMonth()}-${anchor.getDate()}`;
      return `${spaceId || 'global'}:day:${dateKey}`;
    }
    function getLibraryHabitById(hid) {
      const normalized = String(hid);
      const found = LIBRARY_HABITS.find(item => String(item.id) === normalized);
      if (found) return found;
      if (Array.isArray(window.LIBRARY_JSON_DATA)) {
        return window.LIBRARY_JSON_DATA.find(item => String(item.id) === normalized) || null;
      }
      return null;
    }
    function pickHabitTip(hid, seed = '') {
      const habit = getLibraryHabitById(hid);
      const tips = getHabitTips(habit);
      if (!tips.length) {
        return { text: '', index: -1, count: 0, habit };
      }
      const normalizedSeed = String(seed || '');
      const raw = hashStr(`${hid}:${normalizedSeed}`);
      const index = raw % tips.length;
      const safeIndex = (index >= 0 && index < tips.length) ? index : 0;
      return { text: tips[safeIndex], index: safeIndex, count: tips.length, habit };
    }

    function applyNoteDisplayMode(desc, { state = 0 } = {}) {
      if (!desc) return;
      const hasNote = desc.dataset.has === '1';
      const fullText = desc.dataset.full || '';
      const shortText = desc.dataset.short || '';
      const numericState = Number(state) || 0;
      const tipsMode = getTipsDisplayMode();
      const tipText = desc.dataset.tip || '';
      const textHolder = desc.querySelector('.desc-text');
      const setDescText = (value) => {
        if (textHolder) {
          textHolder.textContent = value;
        } else {
          desc.textContent = value;
        }
      };
      const showFull = () => {
        setDescText(fullText);
        desc.classList.remove('hidden');
        desc.classList.add('open');
      };
      const showTip = () => {
        setDescText(tipText);
        desc.classList.remove('hidden');
        desc.classList.add('open');
      };
      const hideShort = () => {
        desc.classList.remove('open');
        desc.classList.add('hidden');
        setDescText(shortText);
      };
      if (!hasNote && tipText) {
        if (tipsMode === 'oui') {
          showTip();
          return;
        }
        if (tipsMode === 'auto' && numericState === 1) {
          showTip();
          return;
        }
      }
      if (hasNote && numericState === 1) {
        showFull();
        return;
      }
      hideShort();
    }

    /* Global helpers */
    function curDate() { const t = new Date(); t.setHours(0, 0, 0, 0); t.setDate(t.getDate() + dayOff); return t; }
    function getSpace() { return (spaceId && SPACES[spaceId]) || null; }
    function getSpaceHabitModeType() {
      const sp = getSpace();
      if (!sp) return 'libre';
      const configured = (sp.habitMode || '').toString().toLowerCase();
      if (configured === 'libre' || configured === 'commun') return configured;
      return isPersonalSpaceType(sp) ? 'libre' : 'commun';
    }
    function shouldShowContextMenuEdit() {
      return hasEditPermission();
    }
    function hideHabit(habitId) {
      if (!habitId) return;
      const normalizedId = String(habitId);
      const hidden = getHiddenHabits();
      if (hidden.includes(normalizedId)) return;
      const next = [...hidden, normalizedId];
      persistHabitProfileFields({ forgottenHabits: next }).catch(() => { });
      showToast('Habitude cachÃ©e.');
      renderCards();
    }
    function showHabit(habitId) {
      if (!habitId) return;
      const normalizedId = String(habitId);
      const next = getHiddenHabits().filter(id => id !== normalizedId);
      persistHabitProfileFields({ forgottenHabits: next }).catch(() => { });
      showToast('Habitude affichÃ©e.');
      renderCards();
    }
    function pinHabitAction(habitId) {
      if (!habitId) return;
      const normalizedId = String(habitId);
      const pinned = getPinnedHabitIds();
      if (pinned.includes(normalizedId)) return;
      const nextPinned = [...pinned, normalizedId];
      persistHabitProfileFields({ pinnedHabits: nextPinned }).catch(() => { });
      showToast('Habitude Ã©pinglÃ©e en haut.');
      renderCards();
    }
    function unpinHabitAction(habitId) {
      if (!habitId) return;
      const normalizedId = String(habitId);
      const nextPinned = getPinnedHabitIds().filter(id => id !== normalizedId);
      persistHabitProfileFields({ pinnedHabits: nextPinned }).catch(() => { });
      showToast('Habitude dÃ©tachÃ©e.');
      renderCards();
    }
    function getSpaceEarliestDate() {
      const sp = getSpace();
      if (!sp) return null;
      const created = timestampToDate(sp.createdAt);
      if (!created) return null;
      created.setHours(0, 0, 0, 0);
      return created;
    }
    function getEarliestDayOff() {
      const earliest = getSpaceEarliestDate();
      if (!earliest) return MIN_DAY_OFF;
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return Math.round((earliest - today) / 86400000);
    }
    function clampDayOff(value) {
      return Math.max(value, getEarliestDayOff());
    }
    function listChallenges() {
      const space = getSpace();
      if (!space) return [];
      return (space.ch || []).filter(habit => {
        if (!habit) return false;
        if (habit.deleted) return false;
        if (DELETED_HABITS.has(habit.id)) return false;
        return true;
      });
    }
    function findAny(id) {
      const map = new Map();
      Object.values(SPACES).forEach(space => { (space.ch || []).forEach(h => { if (h?.id) map.set(h.id, h); }); });
      if (map.has(id)) return map.get(id);
      return LIBRARY_HABITS.find(h => h.id === id);
    }
    function habitLabel(it) {
      if (!it) return '';
      const custom = HABIT_TITLE_CUSTOM[it.id];
      if (custom && custom.trim()) return custom.trim();
      return it.titre || it.title || '';
    }

    function renderDateBar() {
      const d = curDate();
      $("#dateLabel").textContent = fmtDate(d);
    }

    function getOwnerNameFromEvent(event) {
      return event.owner || event.actorName || event.ownerName || displayNameFromEmail(event.userEmail) || 'Moi';
    }
    function getSpaceEvents(spaceId, since = null) {
      if (!spaceId) return [];
      const normalizedSpaceId = String(spaceId);
      return (SPACE_ACTIVITIES[spaceId] || []).map(evt => {
        if (!evt) return null;
        if (evt.spaceId && String(evt.spaceId) !== normalizedSpaceId) return null;
        const recordedAt = timestampToDate(evt.recordedAt);
        if (!recordedAt) return null;
        return { ...evt, recordedAt };
      }).filter(evt => !!evt && (!since || evt.recordedAt >= since));
    }
    function getHabitRecords(spaceId, habitId, since = null, ownerFilter = '__all__') {
      if (!habitId) return [];
      const events = getSpaceEvents(spaceId, since).filter(ev => ev.type === 'realization' && ev.habitId === habitId);
      const map = new Map();
      events.forEach(event => {
        const owner = getOwnerNameFromEvent(event);
        if (ownerFilter !== '__all__' && owner !== ownerFilter) return;
        const dayKey = getEventDayKey(event);
        const key = `${owner}:${event.habitId}:${dayKey}`;
        const prev = map.get(key);
        if (!prev || event.recordedAt > prev.recordedAt) {
          map.set(key, { ...event, owner });
        }
      });
      return Array.from(map.values());
    }
    function getMergedPersonalSpaceRecords(days = DEFAULT_GARDENER_WINDOW_DAYS) {
      const since = days ? addDays(curDate(), -days) : null;
      const ids = getAllPersonalSpaceIds();
      const dedup = new Map();
      ids.forEach(spaceId => {
        const events = getSpaceEvents(spaceId, since);
        events.forEach(event => {
          const owner = getOwnerNameFromEvent(event);
          if (!owner) return;
          const dayKey = getEventDayKey(event);
          if (!dayKey) return;
          const key = `${owner}:${event.habitId}:${dayKey}`;
          const prev = dedup.get(key);
          if (!prev || event.recordedAt > prev.recordedAt) {
            dedup.set(key, { ...event, owner });
          }
        });
      });
      const merged = Array.from(dedup.values());
      merged.sort((a, b) => {
        const aTime = timestampToDate(a.recordedAt)?.getTime() || 0;
        const bTime = timestampToDate(b.recordedAt)?.getTime() || 0;
        return bTime - aTime;
      });
      return merged;
    }
    function getPersonalActivityRecords(days = DEFAULT_GARDENER_WINDOW_DAYS) {
      if (PERSONAL_ACTIVITY_CACHE_DAYS === days && PERSONAL_ACTIVITY_CACHE.length) {
        return PERSONAL_ACTIVITY_CACHE;
      }
      return getMergedPersonalSpaceRecords(days);
    }
    function refreshPersonalActivityCache(days = DEFAULT_GARDENER_WINDOW_DAYS) {
      const now = Date.now();
      if (personalActivityRefreshPromise) {
        return personalActivityRefreshPromise;
      }
      if (PERSONAL_ACTIVITY_CACHE.length &&
        PERSONAL_ACTIVITY_CACHE_DAYS === days &&
        now - PERSONAL_ACTIVITY_LAST_REFRESH < PERSONAL_ACTIVITY_REFRESH_INTERVAL_MS) {
        return Promise.resolve(PERSONAL_ACTIVITY_CACHE);
      }
      personalActivityRefreshPromise = loadPersonalSpaceActivities(days)
        .catch(err => {
          console.warn('refreshPersonalActivityCache', err);
          return getMergedPersonalSpaceRecords(days);
        })
        .finally(() => {
          personalActivityRefreshPromise = null;
        });
      return personalActivityRefreshPromise;
    }
    function triggerPersonalActivityRefresh(days = DEFAULT_GARDENER_WINDOW_DAYS) {
      refreshPersonalActivityCache(days)
        .then(() => {
          renderCards();
          renderSpaceRank();
        })
        .catch(() => {
          renderSpaceRank();
        });
    }
    function getSpaceRecords(spaceId, since = null) {
      const events = getSpaceEvents(spaceId, since).filter(ev => ev.type === 'realization');
      const map = new Map();
      events.forEach(event => {
        const owner = getOwnerNameFromEvent(event);
        const dayKey = getEventDayKey(event);
        const key = `${owner}:${event.habitId}:${dayKey}`;
        const prev = map.get(key);
        if (!prev || event.recordedAt > prev.recordedAt) {
          map.set(key, { ...event, owner });
        }
      });
      return Array.from(map.values());
    }
    /* Emojis & bouton */
    function currentBigEmoji(btn, tot) { return btn.dataset.override || (tot <= 7 ? 'ğŸŒ±' : tot <= 14 ? 'ğŸ€' : tot <= 21 ? 'ğŸŒ¼' : tot <= 28 ? 'ğŸŒ»' : tot <= 35 ? 'ğŸŒ·' : tot <= 42 ? 'ğŸŒ¹' : tot <= 49 ? 'ğŸª»' : tot <= 56 ? 'ğŸ’' : tot <= 64 ? 'ğŸ‹' : 'ğŸ‹'); }
    function drawBtn(btn) {
      const p = +btn.dataset.plants || 0;
      const tot = p;
      const st = +btn.dataset.state || 0;
      const habitEmoji = btn.dataset.habitEmoji || 'ğŸŒ±';
      const bigEmoji = (st === 2) ? currentBigEmoji(btn, tot) : habitEmoji;
      btn.innerHTML = `<div class="big">${bigEmoji}</div>`;
      btn.classList.toggle('done', st === 2);
    }

    /* Init per habit */
    function ensureHabit(hid) {
      const def = findAny(hid) || {};
      if (!BASE_MINUTES[hid]) BASE_MINUTES[hid] = def.baseMin || 15;
      if (HABIT_DESC[hid] === undefined) { HABIT_DESC[hid] = def.desc || ''; }
      const fallbackType = getSpaceHabitModeType();
      HABIT_MODE[hid] = { type: fallbackType, n: 2 };
      if (!DONE_SETS[hid]) DONE_SETS[hid] = new Set();
      if (LOCKED_COMMUN[hid] === undefined) { LOCKED_COMMUN[hid] = false; LOCKED_BY[hid] = null; }
      const target = def || { id: hid };
      cacheRepeatConfigFromHabit(target);
    }

    /* SÃ©lection quotidienne 4â€“9 habitudes par espace (dÃ©terministe par jour) */
    function dayKey() { const d = curDate(); return `${spaceId}:${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`; }
    function hashStr(s) { let h = 0; for (let i = 0; i < s.length; i++) { h = (h * 31 + s.charCodeAt(i)) >>> 0; } return h >>> 0; }
    function rngSeed(seed) { let x = seed >>> 0; return () => { x = (x * 1664525 + 1013904223) >>> 0; return (x >>> 0) / 4294967296; }; }
    function pickVisibleList(arr) {
      return Array.isArray(arr) ? arr.slice() : [];
    }

    /* Cartes */
    function renderCards() {
      const root = $("#cards");
      hideCardContextMenu();
      if (!root) return;
      const filterCounts = new Map(HABIT_FILTERS.map(filter => [filter.key, 0]));
      root.classList.remove('dense-view');
      root.innerHTML = '';
      if (!spaceId) {
        updateHabitFilterCounts(filterCounts);
        return;
      }
      const today = curDate();
      today.setHours(0, 0, 0, 0);
      const personalRecords = getPersonalActivityRecords(DEFAULT_GARDENER_WINDOW_DAYS);
      const selectedDayKey = dayKeyFromDate(today);
      const viewTipSeed = getDescTipSeed(today);
      const items = pickVisibleList(listChallenges());
      items.sort((a, b) => {
        const aMode = (HABIT_MODE[a.id] || {}).type;
        const bMode = (HABIT_MODE[b.id] || {}).type;
        const aIndividual = aMode === 'libre';
        const bIndividual = bMode === 'libre';
        if (aIndividual === bIndividual) return 0;
        return aIndividual ? -1 : 1;
      });
      if (!items.length) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        emptyState.innerHTML = '<strong>Ton jardin est encore vide.</strong><p>Ajoute quelques habitudes via Â« Nouvelle(s) habitude(s) Â» pour commencer Ã  les cultiver.</p>';
        root.appendChild(emptyState);
      } else {
        let cardsAppended = 0;
        const pinnedCards = [];
        const normalCards = [];
        items.forEach(it => {
          if (DELETED_HABITS.has(it.id)) return;
          const pinned = isHabitPinned(it.id);
          ensureHabit(it.id);
          const scheduledToday = shouldOccurOnDate(it, today);
          const visibleToday = scheduledToday;
          const isHiddenHabit = isHabitHidden(it.id);

          const card = document.createElement('article');
          card.className = 'card';
          card.dataset.habitId = String(it.id);
          card.dataset.pinned = pinned ? '1' : '0';
          const cont = document.createElement('div');
          cont.className = 'content';
          const title = document.createElement('div');
          title.className = 'title';
          const left = document.createElement('div');
          left.className = 'left';
          const mode = HABIT_MODE[it.id] || { type: 'libre' };
          const displayTitle = habitLabel(it);
          const pinPrefix = pinned ? 'ğŸ“Œ ' : '';
          left.innerHTML = `<span class="base">${pinPrefix}${displayTitle}</span>`;
          title.append(left);
          const recurrenceLabel = buildHabitRecurrenceLabel(it);
          if (recurrenceLabel) {
            const badge = document.createElement('span');
            badge.className = 'recurrence-badge soft';
            badge.textContent = recurrenceLabel;
            title.append(badge);
          }

          const desc = document.createElement('div');
          desc.className = 'desc';
          const descText = document.createElement('span');
          descText.className = 'desc-text';
          desc.appendChild(descText);
          const gardenerBadge = shouldShowGardenerBadges() ? document.createElement('button') : null;
          if (gardenerBadge) {
            gardenerBadge.type = 'button';
            gardenerBadge.className = 'gardener-badge';
            desc.appendChild(gardenerBadge);
          }
          setupDesc(desc, it.id, { tipSeed: viewTipSeed });

          const friends = document.createElement('div');
          friends.className = 'friends';
          const friendsBadges = document.createElement('div');
          friendsBadges.className = 'friends-badges';
          friends.appendChild(friendsBadges);
          cont.append(title, desc, friends);

          const col = document.createElement('div');
          col.className = 'levelCol';
          const btn = document.createElement('div');
          btn.className = 'levelBtn';
          btn.dataset.cid = it.id;
          btn.dataset.habitEmoji = it.emoji || 'ğŸŒ±';

          const windowStart = new Date(today);
          windowStart.setDate(windowStart.getDate() - 27);
          windowStart.setHours(0, 0, 0, 0);
          const records = getHabitRecords(spaceId, it.id, windowStart);
          const viewRecordedAt = new Date(today);
          let userRecord = records.find(r => isCurrentUserLabel(r.owner)) || null;
          const doneRecord = records.find(r => (r.state || 0) >= 1) || null;
          let ownerRecord = null;
          if (mode.type === 'commun') {
            ownerRecord = doneRecord || records[0] || null;
          } else {
            ownerRecord = userRecord || doneRecord || null;
          }
          const recurrenceConfig = getHabitRepeatConfig(it);
          const freqWeekly = recurrenceConfig?.interval ?? 1;
          const ownerFreq = Math.max(1, Number(ownerRecord?.frequency ?? freqWeekly));
          const ownerModeType = ownerRecord?.modeType || mode.type;
          const resetProgress = ownerRecord && ownerModeType !== mode.type;
          if (resetProgress) {
            ownerRecord = null;
            userRecord = null;
          }
          const ownerNames = Array.from(new Set(records
            .filter(r => (r.state || 0) >= 1)
            .map(r => (r.owner || '').trim())
            .filter(Boolean)
          ));
          const habitRecords = personalRecords.filter(rec => String(rec.habitId) === String(it.id));
          const state2Records = habitRecords.filter(rec => (rec.state || 0) === 2);
          const windowGardeners = new Set(state2Records
            .map(rec => (rec.owner || '').trim())
            .filter(Boolean)
          );
          const windowGardenersCount = windowGardeners.size;
          if (gardenerBadge) {
            gardenerBadge.textContent = `ğŸ§‘â€ğŸŒ¾${windowGardenersCount}`;
            gardenerBadge.dataset.habitId = String(it.id);
            gardenerBadge.classList.toggle('gardener-badge--empty', windowGardenersCount === 0);
            gardenerBadge.addEventListener('click', (event) => {
              event.stopPropagation();
              openDetail(it.id, btn, 'gardeners');
            });
          }
          btn.dataset.ownerList = JSON.stringify(ownerNames);
          const baseMin = BASE_MINUTES[it.id] || 15;
          const ownerState = ownerRecord?.state ?? 0;
          const owner = ownerState > 0 ? (ownerRecord?.owner || '') : '';
          const userState = userRecord?.state ?? 0;
          const storedCount = Number(userRecord?.count ?? 0) || 0;
          const computedCount = storedCount || (userState === 2 ? freqWeekly + 1 : 0);
          const state = userState;
          const contextForCounts = {
            state,
            isHidden: isHiddenHabit,
            dueToday: visibleToday
          };
          HABIT_FILTERS.forEach(filter => {
            if (!habitMatchesFilter(filter.key, contextForCounts)) return;
            if (filter.key === 'hidden' && !visibleToday) return;
            filterCounts.set(filter.key, (filterCounts.get(filter.key) || 0) + 1);
          });
          if (!visibleToday && !pinned) return;
          if (!habitMatchesFilter(activeHabitFilter, contextForCounts)) {
            return;
          }
          btn.dataset.state = String(state);
          btn.dataset.owner = owner;
          btn.dataset.count = '0';
          btn.dataset.baseMin = String(baseMin);
          btn.dataset.recur = String(freqWeekly);
          btn.dataset.basePlants = String(state >= 1 ? baseMin : 0);
          btn.dataset.plants = btn.dataset.basePlants;
          btn.dataset.pinned = pinned ? '1' : '0';

          const setVisualFromState = stNow => {
            const baseEl = title.querySelector('.base');
            const ownerNow = btn.dataset.owner || '';
            applyCardClass(card, stNow, ownerNow, (HABIT_MODE[it.id] || { type: 'libre' }).type);
            baseEl.classList.toggle('strike', stNow === 2 && isCurrentUserLabel(ownerNow));
            ensureModeTag();
          };

          const parseOwnerList = () => {
            try {
              const parsed = JSON.parse(btn.dataset.ownerList || '[]');
              return Array.isArray(parsed) ? parsed : [];
            } catch (err) {
              console.warn('parseOwnerList', err);
              return [];
            }
          };
          const syncOwnerListFromState = (prevOwner) => {
            const owners = new Set(parseOwnerList().filter(Boolean));
            const activeOwner = (btn.dataset.owner || '').trim();
            if ((+btn.dataset.state || 0) >= 1 && activeOwner) {
              owners.add(activeOwner);
            }
            if ((+btn.dataset.state || 0) === 0 && prevOwner) {
              owners.delete(prevOwner);
            }
            btn.dataset.ownerList = JSON.stringify(Array.from(owners));
          };
          const renderBadges = () => {
            const stNow = +btn.dataset.state || 0;
            const ownerNow = btn.dataset.owner || '';
            const ownersNow = parseOwnerList();
            ensureOwnerBadges(friendsBadges, ownersNow, it, btn);
          };

          const applyState = (nst, { keepOwner = false } = {}) => {
            btn.dataset.state = String(nst);
            const previousOwner = (btn.dataset.owner || '').trim();
            if (!keepOwner && nst === 0) {
              btn.dataset.owner = '';
              btn.dataset.count = '0';
            }
            if (nst >= 1 && !btn.dataset.owner) {
              btn.dataset.owner = getCurrentOwnerLabel();
            }
            syncOwnerListFromState(previousOwner);
            drawBtn(btn);
            setVisualFromState(nst);
            renderBadges();
            applyNoteDisplayMode(desc, { state: nst });
            scheduleHabitActivity(it.id, {
              type: 'realization',
              state: nst,
              owner: btn.dataset.owner,
              count: +btn.dataset.count || 0,
              frequency: freqWeekly,
              modeType: mode.type,
              recordedAt: viewRecordedAt
            });
            renderDateBar();
          };

          const clickLibre = () => {
            const st = +btn.dataset.state || 0;
            if (st === 0) {
              btn.dataset.owner = getCurrentOwnerLabel();
              applyState(1);
              return;
            }
            if (st === 1) {
              applyState(2, { keepOwner: true });
              return;
            }
            if (st === 2) {
              applyState(0);
            }
          };

          const clickCommon = () => {
            clickLibre();
          };

          const handleClick = () => {
            const longPressStart = Number(btn.dataset.longPressStart) || 0;
            if (longPressStart && (Date.now() - longPressStart >= CARD_CONTEXT_LONG_PRESS_MS)) {
              shouldSuppressCardClick = true;
            }
            btn.dataset.longPressStart = '0';
            if (shouldSuppressCardClick) {
              shouldSuppressCardClick = false;
              return;
            }
            (mode.type === 'commun') ? clickCommon() : clickLibre();
          };

          drawBtn(btn);
          setVisualFromState(state);
          renderBadges();
          applyNoteDisplayMode(desc, { state });
          col.addEventListener('click', handleClick);
          cont.addEventListener('click', (e) => { if (e.target.closest('.badge')) return; handleClick(); });
          col.append(btn);
          card.append(col, cont);
          attachCardContextHandlers(card, btn, it);
          if (pinned) {
            pinnedCards.push({ card, state, title: displayTitle });
          } else {
            normalCards.push({ card, state, title: displayTitle });
          }
        });
        const sortByStateTitle = (a, b) => {
          const stateOrder = { 1: 0, 0: 1, 2: 2 };
          const aPriority = stateOrder[a.state] ?? 99;
          const bPriority = stateOrder[b.state] ?? 99;
          if (aPriority !== bPriority) return aPriority - bPriority;
          return (a.title || '').localeCompare(b.title || '', 'fr');
        };
        const orderedPinned = pinnedCards.sort(sortByStateTitle).map(entry => entry.card);
        const orderedNormal = normalCards.sort(sortByStateTitle).map(entry => entry.card);
        const orderedCards = [...orderedPinned, ...orderedNormal];
        orderedCards.forEach(card => root.appendChild(card));
        cardsAppended = orderedCards.length;
        const filterInfo = getHabitFilterByKey(activeHabitFilter);
        if (cardsAppended === 0) {
          const label = (filterInfo?.label || '').toLowerCase() || 'disponible';
          const helper = filterInfo?.emptyText || 'Change de filtre pour voir autre chose.';
          const emptyState = document.createElement('div');
          emptyState.className = 'empty-state';
          emptyState.innerHTML = `<strong>Aucune habitude ${label}.</strong><p>${helper}</p>`;
          root.appendChild(emptyState);
        }
      }
      updateHabitFilterCounts(filterCounts);
      updateHabitFilterButtons();
      renderDateBar();
      updateAddModalOptions();
    }
    function getHabitGardenersStats(habitId, sinceDate) {
      if (!spaceId || !habitId) return [];
      const events = getSpaceEvents(spaceId);
      const minutesPerCompletion = BASE_MINUTES[habitId] || DEFAULT_DURATION;
      const stats = new Map();
      const sp = getSpace();
      events.forEach(event => {
        if (String(event.habitId) !== String(habitId)) return;
        if ((event.state || 0) !== 2) return;
        const recordedAt = timestampToDate(event.recordedAt);
        if (!recordedAt) return;
        const ownerLabel = getOwnerNameFromEvent(event);
        const actorName = event.actorName || event.ownerName || '';
        const fallback = displayNameFromEmail(event.userEmail);
        const pseudoCandidate = ((event.actorPseudo || event.owner || ownerLabel || fallback || '').trim());
        if (!pseudoCandidate) return;
        const normalizedOwner = normalizeOwnerLabel(pseudoCandidate);
        if (!normalizedOwner) return;
        const memberKey = normalizeMemberKey(event.userEmail || event.userId || pseudoCandidate);
        const storedFirstName = sp ? getSpaceMemberLabel(sp, memberKey) : '';
        const firstName = (storedFirstName || actorName || '').trim();
        let entry = stats.get(normalizedOwner);
        if (!entry) {
          entry = {
            normalizedOwner,
            ownerLabel: pseudoCandidate,
            pseudo: pseudoCandidate,
            firstName: firstName || '',
            totalMinutes: 0,
            totalDays: new Set(),
            windowDays: new Set(),
            userEmails: new Set(),
            userIds: new Set(),
            lastRecordedAt: 0
          };
          stats.set(normalizedOwner, entry);
        }
        if (firstName && !entry.firstName) {
          entry.firstName = firstName;
        }
        if (event.userEmail) {
          entry.userEmails.add(normalizeEmail(event.userEmail));
        }
        if (event.userId) {
          entry.userIds.add(String(event.userId));
        }
        const dayKey = getEventDayKey(event);
        if (dayKey) {
          entry.totalDays.add(dayKey);
          if (!sinceDate || recordedAt >= sinceDate) {
            entry.windowDays.add(dayKey);
          }
        }
        entry.totalMinutes += minutesPerCompletion;
        const eventTimestamp = recordedAt.getTime();
        if (!entry.lastRecordedAt || eventTimestamp >= entry.lastRecordedAt) {
          entry.lastRecordedAt = eventTimestamp;
          if (Number.isFinite(Number(event.actor30DaysCount))) {
            entry.actor30DaysCount = Number(event.actor30DaysCount);
          }
          if (Number.isFinite(Number(event.actorTotalCount))) {
            entry.actorTotalCount = Number(event.actorTotalCount);
          }
          if (event.actorPseudo) {
            entry.pseudo = event.actorPseudo;
          } else {
            entry.pseudo = pseudoCandidate;
          }
          entry.ownerLabel = pseudoCandidate;
        }
      });
      return Array.from(stats.values()).map(entry => ({
        ownerLabel: entry.ownerLabel,
        firstName: entry.firstName,
        pseudo: entry.pseudo,
        normalizedOwner: entry.normalizedOwner,
        userEmails: entry.userEmails,
        userIds: entry.userIds,
        pastCount: entry.actor30DaysCount ?? entry.windowDays.size,
        totalCount: entry.actorTotalCount ?? entry.totalDays.size,
        minutes: entry.totalMinutes
      }));
    }

    function formatGardenerLabel(entry) {
      const first = (entry.firstName || '').trim();
      const pseudo = (entry.pseudo || entry.ownerLabel || '').trim();
      if (first) {
        if (pseudo) {
          return `${first} (${pseudo})`;
        }
        return first;
      }
      if (pseudo) {
        return `(${pseudo})`;
      }
      return 'â€”';
    }

    function isGardenerCurrentUser(entry) {
      if (isCurrentUserLabel(entry.firstName) || isCurrentUserLabel(entry.pseudo) || isCurrentUserLabel(entry.ownerLabel)) {
        return true;
      }
      const email = currentProfile?.email;
      if (email && entry.userEmails?.has(normalizeEmail(email))) {
        return true;
      }
      const uid = currentProfile?.uid;
      if (uid && entry.userIds?.has(String(uid))) {
        return true;
      }
      return false;
    }

    const HABIT_GARDENER_SORTERS = {
      owner: (a, b) => {
        const aKey = (a.firstName || a.pseudo || a.ownerLabel || '').trim().toLowerCase();
        const bKey = (b.firstName || b.pseudo || b.ownerLabel || '').trim().toLowerCase();
        return aKey.localeCompare(bKey, 'fr', { sensitivity: 'base' });
      },
      window: (a, b) => (a.pastCount - b.pastCount),
      total: (a, b) => (a.totalCount - b.totalCount)
    };

    let habitGardenersSortKey = 'window';
    let habitGardenersSortDesc = true;
    let habitGardenersSortHeaders = [];
    function renderHabitGardeners() {
      const tbody = habitGardenersBody;
      const empty = habitGardenersEmpty;
      if (!tbody) return;
      if (!shouldRenderRankings()) {
        tbody.innerHTML = '';
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 4;
        cell.className = 'miniInfo';
        cell.textContent = 'Les classements sont dÃ©sactivÃ©s pour ce profil.';
        row.append(cell);
        tbody.append(row);
        if (empty) empty.classList.add('hide');
        return;
      }
      tbody.innerHTML = '';
      if (!activeId) {
        if (empty) empty.classList.remove('hide');
        return;
      }
      const sinceDate = addDays(curDate(), -DEFAULT_GARDENER_WINDOW_DAYS);
      const stats = getHabitGardenersStats(activeId, sinceDate);
      if (!stats.length) {
        if (empty) empty.classList.remove('hide');
        return;
      }
      if (empty) empty.classList.add('hide');
      const sorter = HABIT_GARDENER_SORTERS[habitGardenersSortKey] || HABIT_GARDENER_SORTERS.window;
      stats.sort((a, b) => {
        const result = sorter(a, b);
        return habitGardenersSortDesc ? -result : result;
      });
      stats.forEach((entry, index) => {
        const row = document.createElement('tr');
        if (isGardenerCurrentUser(entry)) {
          row.classList.add('self');
        }
        const rankCell = document.createElement('td');
        rankCell.textContent = String(index + 1);
        const ownerCell = document.createElement('td');
        ownerCell.textContent = formatGardenerLabel(entry);
        const recentCell = document.createElement('td');
        recentCell.textContent = String(entry.pastCount);
        const totalCell = document.createElement('td');
        totalCell.textContent = String(entry.totalCount);
        row.append(rankCell, ownerCell, recentCell, totalCell);
        tbody.appendChild(row);
      });
    }

    function updateHabitGardenersSortHeaders() {
      habitGardenersSortHeaders.forEach(th => {
        const isActive = th.dataset.sort === habitGardenersSortKey;
        th.classList.toggle('active', isActive);
        th.dataset.order = isActive ? (habitGardenersSortDesc ? 'â–¼' : 'â–²') : '';
      });
    }

    function setHabitGardenersSort(key) {
      if (!key || !HABIT_GARDENER_SORTERS[key]) return;
      if (habitGardenersSortKey === key) {
        habitGardenersSortDesc = !habitGardenersSortDesc;
      } else {
        habitGardenersSortKey = key;
        habitGardenersSortDesc = key !== 'owner';
      }
      updateHabitGardenersSortHeaders();
      renderHabitGardeners();
    }

    function activateDetailTab(key) {
      const btn = document.querySelector(`#detail .tabs [data-tab="${key}"]`);
      if (!btn) return;
      switchViews(btn, 'data-tab', 'detail');
    }
    /* ===== Calendriers ===== */
    /* ===== Navigation vues ===== */
    function showHome() { hideAll(); $("#home").classList.add('active'); $("#daysWrap").classList.remove('hide') }
    function hideAll() { $$('#home,#detail,#space,#profile').forEach(v => v.classList.remove('active')) }
    $("#backHome").onclick = showHome;

    /* ===== Classement (texte simple â¤ï¸ğŸ¤) ===== */
    const PROFILE_PERIOD_BUTTONS = [
      { selector: '#profilePeriod7', key: '7d', label: '7 jours' },
      { selector: '#profilePeriod30', key: '30d', label: '30 jours' },
      { selector: '#profilePeriodAll', key: 'all', label: 'Total' }
    ];
    const SPACE_PERIOD_BUTTONS = [
      { selector: '#sBtnP7', key: '7d', label: '7 jours' },
      { selector: '#sBtnP30', key: '30d', label: '30 jours' },
      { selector: '#sBtnPAll', key: 'all', label: 'Total' }
    ];
    function applyPeriodButtonLayout(buttons) {
      const allowed = [];
      let defaultKey = null;
      buttons.forEach(item => {
        const btn = $(item.selector);
        if (!btn) return;
        const info = item;
        if (!info) return;
        btn.dataset.period = info.key;
        btn.textContent = info.label;
        allowed.push(info.key);
        if (!defaultKey) defaultKey = info.key;
      });
      return { allowed, defaultKey };
    }
    function updateProfilePeriodButtons() {
      const { allowed, defaultKey } = applyPeriodButtonLayout(PROFILE_PERIOD_BUTTONS);
      if (!allowed.includes(profilePeriod)) {
        profilePeriod = defaultKey || 'all';
      }
      PROFILE_PERIOD_BUTTONS.forEach(item => {
        const btn = $(item.selector);
        if (!btn) return;
        btn.classList.toggle('active', btn.dataset.period === profilePeriod);
      });
    }
    function updateSpacePeriodButtons() {
      const { allowed, defaultKey } = applyPeriodButtonLayout(SPACE_PERIOD_BUTTONS);
      if (!allowed.includes(sPeriod)) {
        sPeriod = defaultKey || 'all';
      }
      SPACE_PERIOD_BUTTONS.forEach(item => {
        const btn = $(item.selector);
        if (!btn) return;
        btn.classList.toggle('active', btn.dataset.period === sPeriod);
      });
    }
    function getWeekRange(count) {
      const now = new Date();
      now.setHours(0, 0, 0, 0);
      const currentWeekStart = getWeekStart(now);
      const lastWeekEnd = new Date(currentWeekStart);
      lastWeekEnd.setDate(lastWeekEnd.getDate() - 1);
      const since = new Date(lastWeekEnd);
      since.setDate(since.getDate() - (7 * count) + 1);
      since.setHours(0, 0, 0, 0);
      return { since, until: lastWeekEnd };
    }
    function resolvePeriodRange(key) {
      if (!key || key === 'all') return { since: null, until: null };
      if (key === '1w') return getWeekRange(1);
      if (key === '4w') return getWeekRange(4);
      if (key === '7d' || key === '30d') {
        const days = Number(key.replace('d', '')) || 0;
        if (!days) return { since: null, until: null };
        const since = new Date();
        since.setHours(0, 0, 0, 0);
        since.setDate(since.getDate() - days);
        return { since };
      }
      return { since: null, until: null };
    }
    function renderRank() {
      const root = $("#rank");
      root.innerHTML = '';
      if (!spaceId || !activeId) return;
      const range = resolvePeriodRange('30d');
      const records = getHabitRecords(spaceId, activeId, range.since);
      const filtered = range.until ? records.filter(rec => rec.recordedAt <= range.until) : records;
      const totals = new Map();
      filtered.forEach(rec => {
        if ((rec.state || 0) >= 1) {
          const minutes = BASE_MINUTES[activeId] || 15;
          totals.set(rec.owner, (totals.get(rec.owner) || 0) + minutes);
        }
      });
      const members = new Set(allMembersOfSpace());
      const rows = Array.from(members).map(name => ({
        n: name,
        me: name === (userName || 'Moi'),
        totalMin: totals.get(name) || 0,
        likes: likes.get(name) || 0,
        help: Math.round(((helps.get(name) || 0) * 15) / 60),
        txt: m2txt(totals.get(name) || 0)
      })).sort((a, b) => b.totalMin - a.totalMin);
      rows.forEach(({ n, totalMin, txt, me }) => {
        const row = document.createElement('div');
        row.className = 'row';
        const left = document.createElement('div');
        left.className = 'leftRank';
        const big = document.createElement('span');
        big.className = 'scoreEmoji';
        big.textContent = txt;
        const nameBtn = document.createElement('button');
        nameBtn.type = 'button';
        nameBtn.className = 'profile-link';
        nameBtn.textContent = `${n}${me ? ' (toi)' : ''}`;
        nameBtn.addEventListener('click', () => openProfileView(n, 'detail'));
        left.append(big, nameBtn);
        row.append(left);
        root.appendChild(row);
      });
      renderProfileStats();
    }
    function showDetailView() { hideAll(); $("#detail").classList.add('active'); $("#daysWrap").classList.add('hide') }
    function renderProfileStats() {
      updateProfilePeriodButtons();
      const root = $("#profileHabits");
      const empty = $("#profileEmpty");
      if (root) root.innerHTML = '';
      if (!spaceId || !activeProfileName) {
        if (empty) empty.classList.remove('hide');
        return;
      }
      const normalized = normalizeOwnerLabel(activeProfileName);
      const range = resolvePeriodRange(profilePeriod);
      let records = getSpaceRecords(spaceId, range.since);
      if (range.until) {
        records = records.filter(rec => rec.recordedAt <= range.until);
      }
      records = records.filter(rec => normalizeOwnerLabel(rec.owner) === normalized);
      const minutesPerHabit = new Map();
      records.forEach(rec => {
        if ((rec.state || 0) >= 1) {
          const minutes = BASE_MINUTES[rec.habitId] || 15;
          minutesPerHabit.set(rec.habitId, (minutesPerHabit.get(rec.habitId) || 0) + minutes);
        }
      });
      const habitIds = new Set(minutesPerHabit.keys());
      if (!habitIds.size) {
        if (empty) empty.classList.remove('hide');
        return;
      }
      if (empty) empty.classList.add('hide');
      const entries = Array.from(habitIds).map(hid => ({
        habit: findAny(hid),
        minutes: minutesPerHabit.get(hid) || 0,
        id: hid
      })).sort((a, b) => b.minutes - a.minutes);
      entries.forEach(item => {
        const name = habitLabel(item.habit) || 'Habitude';
        const row = document.createElement('div');
        row.className = 'row profile-habit';
        const left = document.createElement('div');
        left.className = 'leftRank profile-habit-left';
        const durationScore = document.createElement('span');
        durationScore.className = 'scoreEmoji';
        const totalMinutes = item.minutes || 0;
        durationScore.textContent = m2txt(totalMinutes);
        const title = document.createElement('div');
        title.className = 'profile-habit-title';
        const emoji = document.createElement('span');
        emoji.textContent = item.habit?.emoji || 'ğŸŒ¿';
        const text = document.createElement('span');
        text.textContent = name;
        title.append(emoji, text);
        left.append(durationScore, title);
        row.append(left);
        row.addEventListener('click', () => {
          openDetail(item.id, row);
        });
        root.appendChild(row);
      });
    }
    function resolveProfileEmail(name) {
      const normalizedTarget = normalizeOwnerLabel(name);
      if (!normalizedTarget) return null;
      if (currentProfile && normalizeOwnerLabel(getCurrentOwnerLabel()) === normalizedTarget) {
        return currentProfile.email || null;
      }
      for (const email of sp.members || []) {
        if (normalizeOwnerLabel(displayNameFromEmail(email)) === normalizedTarget) {
          return email;
        }
      }
      return null;
    }
    function updateProfileRemoveButton() {
      const removeBtn = $("#removeFromGardenBtn");
      const grantBtn = $("#grantAccessBtn");
      if (!activeProfileName) {
        if (removeBtn) removeBtn.classList.add('hide');
        if (grantBtn) grantBtn.classList.add('hide');
        return;
      }
      const sp = getSpace();
      const ownerName = sp ? getSpaceOwnerLabel(sp) : '';
      const isOwner = normalizeOwnerLabel(activeProfileName) === normalizeOwnerLabel(ownerName);
      const isSelf = normalizeOwnerLabel(activeProfileName) === normalizeOwnerLabel(getCurrentOwnerLabel());
      const shouldShow = isCurrentSpaceAdmin() && !isOwner && !isSelf;
      if (removeBtn) removeBtn.classList.toggle('hide', !shouldShow);
      if (grantBtn) grantBtn.classList.toggle('hide', !shouldShow);
    }
    function openProfileView(name, returnView = 'detail') {
      if (!name) return;
      activeProfileName = name;
      profileReturnView = returnView || 'detail';
      activeProfileEmail = resolveProfileEmail(name);
      updateProfilePeriodButtons();
      hideAll();
      $("#profile").classList.add('active');
      $("#daysWrap").classList.add('hide');
      $("#profileTitle").textContent = name;
      updateProfileRemoveButton();
      renderProfileStats();
    }
    function closeProfileView() {
      const target = profileReturnView;
      profileReturnView = 'detail';
      activeProfileName = null;
      activeProfileEmail = null;
      hideAll();
      if (target === 'space') {
        openSpacePage();
      } else if (activeId) {
        showDetailView();
      } else {
        showHome();
      }
    }
    async function removeActiveProfileMember() {
      if (!activeProfileEmail || !spaceId) return;
      if (!confirm('Retirer ce jardinier du jardin ?')) return;
      const normalized = normalizeEmail(activeProfileEmail);
      const sp = getSpace();
      if (!sp) return;
      sp.members = (sp.members || []).filter(email => normalizeEmail(email) !== normalized);
      await persistSpaceDoc(spaceId, { members: sp.members });
      renderSpaceRank();
      renderRank();
      renderCards();
      closeProfileView();
    }

    async function grantActiveProfileAccess() {
      if (!activeProfileName || !spaceId) return;
      if (!isCurrentSpaceAdmin()) return;
      const sp = getSpace();
      if (!sp) return;
      const token = genInviteToken();
      const link = `${inviteBaseUrl()}?invite=${token}`;
      const ownerName = getSpaceOwnerLabel(sp);
      const inviteData = {
        ownerName,
        invitedName: activeProfileName,
        spaceId,
        spacePseudo: sp.pseudo || '',
        spaceDesc: (sp.desc || '').trim(),
        gardenLabel: sp.label || 'ton jardin',
        created: Date.now(),
        ownerId: sp.ownerId || null
      };
      await persistInviteDoc(token, inviteData);
      INVITE_CACHE[token] = { token, ...inviteData };
      if (typeof renderInviteList === 'function') renderInviteList();
      showToast('Lien gÃ©nÃ©rÃ© !', { type: 'success' });
      copyText(link);
    }

    /* ===== ParamÃ¨tres habitude ===== */
    let activeId = null, refBtn = null;
    function openDetail(id, btnRef, targetTab = 'settings') {
      const it = findAny(id);
      if (!it) {
        console.warn('openDetail: habit not found', id);
        return;
      }
      activeId = id;
      refBtn = btnRef;
      hideAll();
      $("#detail").classList.add('active');
      $("#daysWrap").classList.add('hide');
      $("#detailTitle").textContent = `${it.emoji} ${habitLabel(it)}`;
      renderHabitSettings();
      activateDetailTab(targetTab);
    }

    function renderHabitSettings() {
      if (!activeId) return; ensureHabit(activeId);
      const it = findAny(activeId);
      const isAdmin = isCurrentSpaceAdmin();

      const titleInput = $("#habitTitleInput"), emojiEl = $("#habitTitleEmoji");
      if (it && titleInput && emojiEl) {
        emojiEl.textContent = it.emoji || 'ğŸŒ±';
        if (document.activeElement !== titleInput) titleInput.value = habitLabel(it);
        titleInput.disabled = !isAdmin;
        if (!titleInput.dataset.bound) {
          titleInput.addEventListener('input', () => { const raw = titleInput.value; if (raw.trim()) { HABIT_TITLE_CUSTOM[activeId] = raw; } else { delete HABIT_TITLE_CUSTOM[activeId]; } $("#detailTitle").textContent = `${it.emoji} ${habitLabel(it)}`; renderCards(); });
          titleInput.dataset.bound = '1';
        }
      }
      const desc = $("#habitDesc");
      if (desc) {
        desc.value = HABIT_DESC[activeId] || '';
        desc.disabled = !isAdmin;
        if (!desc.dataset.bound) {
          desc.addEventListener('input', () => { HABIT_DESC[activeId] = desc.value; HAS_DESC[activeId] = !!desc.value.trim(); renderCards(); });
          desc.dataset.bound = '1';
        }
      }


      const recurrenceDaysWrapper = $("#habitRecurrenceDays");
      const recurrenceDayInputs = recurrenceDaysWrapper ? Array.from(recurrenceDaysWrapper.querySelectorAll('input[type=checkbox]')) : [];
      const recurrenceModeRadios = Array.from(document.querySelectorAll('input[name="habitRecurrenceMode"]'));
      const recurrenceIntervalSelect = $("#habitRecurrenceInterval");
      const recurrenceStartDateInput = $("#habitStartDate");
      const recurrenceEndDateInput = $("#habitEndDate");
      const storedRecurrence = getHabitRepeatConfig(it);
      const defaultMode = (storedRecurrence.interval ?? 1) > 1 ? 'interval' : 'weekly';
      const getSelectedMode = () => getSelectedRecurrenceMode(recurrenceModeRadios);
      const applyMode = (mode) => applyRecurrenceMode(mode, {
        modeRadios: recurrenceModeRadios,
        intervalSelect: recurrenceIntervalSelect,
        dayInputs: recurrenceDayInputs,
        isAdmin
      });
      recurrenceModeRadios.forEach(radio => {
        radio.disabled = !isAdmin;
        if (!radio.dataset.bound) {
          radio.addEventListener('change', () => applyMode(getSelectedMode()));
          radio.dataset.bound = '1';
        }
      });
      applyMode(defaultMode);
      const recurrenceDays = storedRecurrence.weekDays && storedRecurrence.weekDays.length ? storedRecurrence.weekDays : WEEKDAY_ORDER.slice();
      setRecurrenceDaysOnInputs(recurrenceDayInputs, recurrenceDays, isAdmin);
      bindRecurrenceDaySelectionBehavior(recurrenceDayInputs, getSelectedMode);
      if (recurrenceIntervalSelect) {
        const storedInterval = Number.isFinite(Number(storedRecurrence.interval)) ? Number(storedRecurrence.interval) : 2;
        const normalizedInterval = Math.max(2, storedInterval);
        recurrenceIntervalSelect.dataset.defaultInterval = String(normalizedInterval);
        recurrenceIntervalSelect.dataset.savedValue = String(normalizedInterval);
        recurrenceIntervalSelect.value = storedRecurrence.unit === 'week' ? String(normalizedInterval) : '';
      }
      if (recurrenceStartDateInput) {
        recurrenceStartDateInput.value = storedRecurrence.startDate || toIsoDateString(it?.addedAt || curDate());
        recurrenceStartDateInput.disabled = !isAdmin;
        if (!recurrenceStartDateInput.dataset.bound) {
          recurrenceStartDateInput.addEventListener('change', () => {
            if (!recurrenceDayInputs.length) return;
          });
          recurrenceStartDateInput.dataset.bound = '1';
        }
      }
      if (recurrenceEndDateInput) {
        recurrenceEndDateInput.value = storedRecurrence.endDate || '';
        recurrenceEndDateInput.disabled = !isAdmin;
        if (!recurrenceEndDateInput.dataset.bound) {
          recurrenceEndDateInput.dataset.bound = '1';
        }
      }


      const del = $("#deleteHabitBtn");
      if (del && !del.dataset.bound) {
        del.onclick = () => {
          if (!requireAdmin('supprimer une habitude')) return;
          if (!confirm('Supprimer cette habitude ?')) return;
          DELETED_HABITS.add(activeId);
          const sp = SPACES[spaceId];
          if (sp && Array.isArray(sp.ch)) {
            sp.ch = sp.ch.filter(habit => habit?.id !== activeId);
          }
          persistHabit(spaceId, { id: activeId, deleted: true });
          close(mHabit);
          activeId = null;
          showHome();
          renderCards();
        };
        del.dataset.bound = '1';
      }
      if (del) {
        del.disabled = !isAdmin;
      }

      const save = $("#saveHabitBtn");
      if (save && !save.dataset.bound) {
        save.onclick = async () => {
          if (!requireAdmin('modifier une habitude')) return;
          const repeatConfig = readRecurrenceConfigFromForm(it, {
            modeRadios: recurrenceModeRadios,
            intervalSelect: recurrenceIntervalSelect,
            startDateInput: recurrenceStartDateInput,
            endDateInput: recurrenceEndDateInput,
            dayInputs: recurrenceDayInputs
          });
          const repeatConfigPayload = {
            ...repeatConfig,
            weekDays: Array.isArray(repeatConfig.weekDays) ? repeatConfig.weekDays.slice() : []
          };
          const payload = {
            id: activeId,
            customTitle: HABIT_TITLE_CUSTOM[activeId] || '',
            desc: HABIT_DESC[activeId] || '',
            note: HABIT_DESC[activeId] || '',
            mode: HABIT_MODE[activeId] || null,
            frequency: repeatConfig.interval,
            repeatConfig: repeatConfigPayload
          };
          if (it) {
            it.repeatConfig = { ...repeatConfigPayload };
            cacheRepeatConfigFromHabit(it);
          }
          await persistHabit(spaceId, payload);
          activeId = null;
          renderCards();
          showHome();
        };
        save.dataset.bound = '1';
      }
      if (save) {
        save.disabled = !isAdmin;
      }
    }

    /* ===== Espace ===== */
    function openSpacePage() { hideAll(); $("#space").classList.add('active'); $("#daysWrap").classList.add('hide'); updSpaceHeader(); renderSpaceRank(); setupSpaceInfo(); populateSpaceWho(); renderSpaceCalendar(); maybeTogglePrivateAdd(); triggerPersonalActivityRefresh(); if (typeof window !== 'undefined') { window.scrollTo({ top: 0, behavior: 'auto' }); } }
    function updSpaceHeader() {
      const sp = getSpace();
      if (sp) {
        const headerLabel = isPersonalSpaceType(sp) ? (currentProfile?.pseudo || sp.pseudo || sp.label || '') : (sp.label || '');
        $("#spaceHeaderTitle").textContent = headerLabel;
        $("#paramSpaceLabel").value = sp.label || '';
      } else {
        $("#spaceHeaderTitle").textContent = '';
        $("#paramSpaceLabel").value = '';
      }
      const currentMemberKey = getCurrentSpaceMemberKey(sp);
      const currentMemberName = getSpaceMemberLabel(sp, currentMemberKey);
      $("#paramName").value = currentMemberName || getLastMemberName() || '';
    }
    function setupSpaceInfo() {
      const sp = getSpace();
      const descInput = $("#spaceDescInfo");
      const nameInput = $("#paramName");
      const descValue = SPACE_DESC_TXT[spaceId] ?? (sp?.desc || '');
      if (descInput) {
        descInput.value = descValue;
        descInput.classList.toggle('editing', !!sp);
        if (sp && spaceId) {
          descInput.oninput = () => {
            const nextValue = descInput.value;
            SPACE_DESC_TXT[spaceId] = nextValue;
            sp.desc = nextValue;
            persistSpaceDoc(spaceId, { desc: nextValue });
          };
        } else {
          descInput.oninput = null;
        }
      }
      if (!sp) {
        if (nameInput) {
          nameInput.value = getLastMemberName() || '';
        }
        return;
      }
      const spaceLabelField = $("#spaceLabelField");
      const spacePseudoField = $("#spacePseudoField");
      const pseudoInput = $("#paramSpacePseudo");
      const profileModeField = $("#spaceProfileModeField");
      const profileModeHint = $("#profileModeHint");
      const deleteAccountBtn = $("#deleteAccountBtn");
      const personalDeleteHint = $("#personalDeleteHint");
      const introField = $("#spaceIntroField");
      const rightsField = $("#spaceRightsField");
      const isPersonal = isPersonalSpaceType(sp);
      const isGroupSpace = ((sp?.type || '').toString().toLowerCase() === 'group');
      const isOwner = isCurrentSpaceAdmin();
      if (spaceLabelField) {
        spaceLabelField.classList.toggle('hide', isPersonal);
      }
      if (spacePseudoField) {
        spacePseudoField.classList.toggle('hide', !(isPersonal || isGroupSpace));
        const subtitle = spacePseudoField.querySelector('.subtitle');
        if (subtitle) {
          subtitle.textContent = isPersonal
            ? "Ton pseudo est visible dans ton espace individuel."
            : "Le pseudo du jardin est utilisÃ© pour partager lâ€™espace.";
        }
      }
      if (profileModeField) {
        profileModeField.classList.toggle('hide', !isPersonal);
      }
      if (introField) {
        introField.classList.toggle('hide', isPersonal);
      }
      if (rightsField) {
        rightsField.classList.toggle('hide', isPersonal);
      }
      if (pseudoInput) {
        if (isPersonal) {
          pseudoInput.value = currentProfile?.pseudo || sp?.pseudo || sp?.label || '';
        } else if (isGroupSpace) {
          pseudoInput.value = sp?.pseudo || '';
        } else {
          pseudoInput.value = '';
        }
      }
      if (profileModeField) {
        const profileModeButtons = Array.from(profileModeField.querySelectorAll('.profile-mode-option'));
        const refreshProfileModeHint = () => {
          if (!profileModeHint) return;
          const info = PROFILE_MODE_INFO[getProfileMode()] || PROFILE_MODE_INFO[DEFAULT_PROFILE_MODE];
          profileModeHint.textContent = info?.summary || '';
        };
        const highlightProfileModeOption = (mode) => {
          profileModeButtons.forEach((btn) => {
            const isActive = btn.dataset.mode === mode;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
        };
        const localButton = profileModeButtons.find((btn) => btn.dataset.mode === 'local');
        if (localButton) {
          const hideLocal = !!currentProfile?.email;
          localButton.disabled = hideLocal;
          localButton.setAttribute('aria-hidden', hideLocal ? 'true' : 'false');
        }
        profileModeButtons.forEach((btn) => {
          if (btn.dataset.bound) return;
          btn.addEventListener('click', () => {
            if (btn.disabled) return;
            const mode = btn.dataset.mode;
            updateProfileMode(mode);
            highlightProfileModeOption(mode);
            refreshProfileModeHint();
          });
          btn.dataset.bound = '1';
        });
        highlightProfileModeOption(getProfileMode());
        refreshProfileModeHint();
      }
      if (deleteAccountBtn) {
        deleteAccountBtn.classList.toggle('hide', !(isOwner && isPersonal));
      }
      if (personalDeleteHint) {
        personalDeleteHint.classList.toggle('hide', !isPersonal);
      }
      const rightsSelect = $("#spaceEditorRights");
      if (rightsSelect) {
        rightsSelect.value = getEditorRights(sp);
        if (!rightsSelect.dataset.bound) {
          rightsSelect.addEventListener('change', () => {
            if (!spaceId) return;
            const mode = rightsSelect.value === 'registered' ? 'registered' : 'admin';
            sp.editorRights = mode;
            persistSpaceDoc(spaceId, { editorRights: mode });
          });
          rightsSelect.dataset.bound = '1';
        }
      }
      refreshOwnerPanel();
      const quitBtn = $("#quitSpaceBtn");
      if (quitBtn && !quitBtn.dataset.bound) {
        quitBtn.onclick = () => showQuitModal();
        quitBtn.dataset.bound = '1';
      }
      const saveSettingsBtn = $("#saveSpaceSettings");
      if (saveSettingsBtn && !saveSettingsBtn.dataset.bound) {
        saveSettingsBtn.onclick = async () => {
          if (!spaceId) return;
          const sp = getSpace();
          const currentKey = getCurrentSpaceMemberKey(sp);
          const customName = (nameInput?.value || '').trim();
          if (currentKey) {
            await updateSpaceMemberName(spaceId, currentKey, customName, { persist: false });
          }
          const ownerKey = sp ? normalizeMemberKey(sp.ownerId || '') : '';
          if (ownerKey && ownerKey !== currentKey) {
            await updateSpaceMemberName(spaceId, ownerKey, customName, { persist: false });
          }
          await persistSpaceDoc(spaceId);
          showToast('RÃ©glages sauvegardÃ©s.', { type: 'success' });
        };
        saveSettingsBtn.dataset.bound = '1';
      }
    }

    function refreshOwnerPanel() {
      const sp = getSpace();
      const ownerControls = $("#ownerControls");
      const ownerHint = $("#ownerControlsHint");
      const deleteBtn = $("#deleteSpaceBtn");
      const guestQuitControls = $("#guestQuitControls");
      const isOwner = isCurrentSpaceAdmin();
      const isPersonal = isPersonalSpaceType(sp);
      if (ownerControls) ownerControls.classList.toggle('hide', !isOwner || isPersonal);
      if (guestQuitControls) guestQuitControls.classList.toggle('hide', isOwner || isPersonal);
      if (deleteBtn) deleteBtn.disabled = !isOwner;
      if (ownerHint) {
        ownerHint.textContent = '';
      }
    }


    async function leaveCurrentSpace() {
      if (!spaceId || !currentProfile?.email) return;
      const email = currentProfile.email;
      await removeMemberFromSpace(spaceId, email);
      await deleteMemberActivities(spaceId, email);
      allowedSpaces = allowedSpaces.filter(id => id !== spaceId);
      const nextSpace = allowedSpaces[0] || null;
      spaceId = nextSpace;
      updSel();
      renderCards();
      if (spaceId) {
        openSpacePage();
      } else {
        showHome();
      }
    }

    async function removeMemberFromSpace(spaceIdArg, email) {
      if (!spaceIdArg || !email) return;
      const normalized = normalizeEmail(email);
      try {
        if (HABITU_FIREBASE_DB) {
          await HABITU_FIREBASE_DB.collection('spaces').doc(spaceIdArg)
            .update({ members: firebase.firestore.FieldValue.arrayRemove(normalized) });
        }
      } catch (err) {
        console.warn('removeMemberFromSpace', err);
      }
      const sp = SPACES[spaceIdArg];
      if (sp) {
        sp.members = (sp.members || []).filter(mail => normalizeEmail(mail) !== normalized);
      }
    }

    async function deleteMemberActivities(spaceIdArg, email) {
      if (!spaceIdArg || !email) return;
      const normalized = normalizeEmail(email);
      if (SPACE_ACTIVITIES[spaceIdArg]) {
        SPACE_ACTIVITIES[spaceIdArg] = (SPACE_ACTIVITIES[spaceIdArg] || []).filter(ev => normalizeEmail(ev.userEmail || '') !== normalized);
      }
      if (!HABITU_FIREBASE_DB) return;
      try {
        const snapshot = await HABITU_FIREBASE_DB.collection('activities')
          .where('spaceId', '==', spaceIdArg)
          .where('userEmail', '==', normalized)
          .get();
        if (snapshot.empty) return;
        const batch = HABITU_FIREBASE_DB.batch();
        snapshot.docs.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
      } catch (err) {
        console.warn('deleteMemberActivities', err);
      }
    }

    async function updateSpaceOwner(spaceIdArg, email) {
      if (!spaceIdArg || !email) return false;
      const sp = SPACES[spaceIdArg];
      if (!sp) return false;
      const normalized = normalizeEmail(email);
      const targetId = resolveMemberUserId(spaceIdArg, normalized);
      if (!targetId) {
        showToast('Impossible de transfÃ©rer sans identifiant valide.', { type: 'error' });
        return false;
      }
      sp.ownerId = targetId;
      await persistSpaceDoc(spaceIdArg);
      refreshOwnerPanel();
      updSpaceHeader();
      renderSpaceRank();
      setupSpaceInfo();
      return true;
    }


    async function deleteCurrentSpace() {
      if (!spaceId) return;
      const target = spaceId;
      try {
        if (HABITU_FIREBASE_DB) {
          const spaceRef = HABITU_FIREBASE_DB.collection('spaces').doc(target);
          const [habitsSnap, activitiesSnap] = await Promise.all([
            spaceRef.collection('habits').get(),
            HABITU_FIREBASE_DB.collection('activities').where('spaceId', '==', target).get()
          ]);
          const batch = HABITU_FIREBASE_DB.batch();
          habitsSnap.docs.forEach(doc => batch.delete(doc.ref));
          activitiesSnap.docs.forEach(doc => batch.delete(doc.ref));
          batch.delete(spaceRef);
          await batch.commit();
        }
      } catch (err) {
        console.warn('deleteSpace', err);
      }
      delete SPACES[target];
      delete SPACE_ACTIVITIES[target];
      allowedSpaces = allowedSpaces.filter(id => id !== target);
      const nextSpace = allowedSpaces[0] || null;
      spaceId = nextSpace;
      updSel();
      renderCards();
      if (spaceId) {
        openSpacePage();
      } else {
        showHome();
      }
    }

    async function handleAccountDeletion() {
      if (!spaceId) return;
      if (!confirm('Supprimer ton compte supprimera toutes tes infos. Continuer ?')) return;
      await deleteCurrentSpace();
      clearGuestSpaces();
      persistProfile(null);
      clearLocalState();
      if (HABITU_FIREBASE_AUTH?.signOut) {
        try {
          await HABITU_FIREBASE_AUTH.signOut();
        } catch (err) {
          console.warn('signOut after account deletion', err);
        }
      }
    }

    function allMembersOfSpace() {
      const sp = getSpace();
      const keys = new Set();
      (sp?.members || []).forEach(member => {
        const normalized = normalizeMemberKey(member);
        if (normalized) keys.add(normalized);
      });
      const currentKey = getCurrentSpaceMemberKey(sp);
      if (currentKey) keys.add(currentKey);
      if (!keys.size) keys.add('__current__');
      const names = [];
      keys.forEach(key => {
        const label = getSpaceMemberLabel(sp, key) || ((key === '__current__' || isCurrentMemberKey(key)) ? 'Moi' : '');
        if (label) names.push(label);
      });
      if (!names.length) names.push('Moi');
      return names;
    }
    function renderSpaceRank() {
      updateSpacePeriodButtons();
      const root = $("#spaceRank");
      root.innerHTML = '';
      if (!spaceId) return;
      if (!shouldRenderRankings()) {
        if (root) {
          const placeholder = document.createElement('div');
          placeholder.className = 'miniInfo';
          placeholder.textContent = 'Les classements sont dÃ©sactivÃ©s pour ce profil.';
          root.appendChild(placeholder);
        }
        renderProfileStats();
        return;
      }
      const range = resolvePeriodRange(sPeriod);
      const records = getPersonalActivityRecords(DEFAULT_GARDENER_WINDOW_DAYS);
      const filtered = records.filter(rec => {
        const recorded = rec.recordedAt;
        if (!recorded || (rec.state || 0) < 1) return false;
        if (range.since && recorded < range.since) return false;
        if (range.until && recorded > range.until) return false;
        return true;
      });
      if (!filtered.length) {
        const empty = document.createElement('div');
        empty.className = 'miniInfo';
        empty.textContent = 'Aucune activitÃ© rÃ©cente pour lâ€™instant.';
        root.appendChild(empty);
        renderProfileStats();
        return;
      }
      const totals = new Map();
      const participantLabels = new Set();
      filtered.forEach(rec => {
        const owner = (rec.owner || '').trim();
        if (!owner) return;
        totals.set(owner, (totals.get(owner) || 0) + 1);
        participantLabels.add(owner);
      });
      participantLabels.add(getCurrentOwnerLabel());
      const rows = Array.from(participantLabels)
        .map(label => ({
          n: label,
          me: isCurrentUserLabel(label),
          totalCount: totals.get(label) || 0,
          txt: String(totals.get(label) || 0)
        }))
        .filter(row => row.n)
        .sort((a, b) => b.totalCount - a.totalCount);
      rows.forEach(({ n, totalCount, txt, me }) => {
        const row = document.createElement('div');
        row.className = 'row';
        const left = document.createElement('div');
        left.className = 'leftRank';
        const big = document.createElement('span');
        big.className = 'scoreEmoji';
        big.textContent = txt;
        const nameBtn = document.createElement('button');
        nameBtn.type = 'button';
        nameBtn.className = 'profile-link';
        nameBtn.textContent = `${n}${me ? ' (toi)' : ''}`;
        nameBtn.addEventListener('click', () => openProfileView(n, 'space'));
        left.append(big, nameBtn);
        row.append(left);
        root.appendChild(row);
      });
      renderProfileStats();
    }
    let sPeriod = '30d';
    const sBtnP7 = $("#sBtnP7");
    if (sBtnP7) {
      sBtnP7.onclick = () => {
        const btn = $("#sBtnP7");
        sPeriod = btn?.dataset.period || sPeriod;
        renderSpaceRank();
      };
    }
    const sBtnP30 = $("#sBtnP30");
    if (sBtnP30) {
      sBtnP30.onclick = () => {
        const btn = $("#sBtnP30");
        sPeriod = btn?.dataset.period || sPeriod;
        renderSpaceRank();
      };
    }
    const sBtnPAll = $("#sBtnPAll");
    if (sBtnPAll) {
      sBtnPAll.onclick = () => {
        const btn = $("#sBtnPAll");
        sPeriod = btn?.dataset.period || sPeriod;
        renderSpaceRank();
      };
    }
    $('#profilePeriod7').onclick = () => {
      const btn = $("#profilePeriod7");
      profilePeriod = btn?.dataset.period || profilePeriod;
      renderProfileStats();
    };
    $('#profilePeriod30').onclick = () => {
      const btn = $("#profilePeriod30");
      profilePeriod = btn?.dataset.period || profilePeriod;
      renderProfileStats();
    };
    $('#profilePeriodAll').onclick = () => {
      const btn = $("#profilePeriodAll");
      profilePeriod = btn?.dataset.period || profilePeriod;
      renderProfileStats();
    };
    $('#backFromProfile').onclick = closeProfileView;
    $('#removeFromGardenBtn').onclick = removeActiveProfileMember;
    $('#grantAccessBtn').onclick = grantActiveProfileAccess;

    let sCalOff = 0;
    function minfo(off = 0) {
      const b = new Date();
      b.setDate(1);
      b.setMonth(b.getMonth() + off);
      const y = b.getFullYear();
      const m = b.getMonth();
      return {
        y,
        m,
        fd: (new Date(y, m, 1).getDay() + 6) % 7,
        days: new Date(y, m + 1, 0).getDate()
      };
    }
    function populateSpaceWho() { const sel = $("#sCalWho"); sel.innerHTML = ''; sel.add(new Option('Tous', '__all__')); allMembersOfSpace().forEach(n => sel.add(new Option(n, n))); sel.value = '__all__'; }
    function renderSpaceCalendar() {
      const wrap = $("#sCal");
      wrap.innerHTML = '';
      if (!spaceId) return;
      const space = getSpace();
      const { y, m, fd, days } = minfo(sCalOff);
      const months = ['Jan', 'FÃ©v', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'AoÃ»', 'Sep', 'Oct', 'Nov', 'DÃ©c'];
      const cellHeight = 55;
      const gap = 6;
      const totalCells = fd + days;
      const rows = Math.max(1, Math.ceil(totalCells / 7));
      wrap.style.position = 'relative';
      wrap.style.minHeight = `${rows * (cellHeight + gap) - gap}px`;
      const ownerFilter = $("#sCalWho")?.value || '__all__';
      const records = getSpaceRecords(spaceId);
      const monthMap = new Map();
      records.forEach(rec => {
        if (rec.recordedAt.getFullYear() !== y || rec.recordedAt.getMonth() !== m) return;
        if (ownerFilter !== '__all__' && ownerFilter !== rec.owner) return;
        const day = rec.recordedAt.getDate();
        const minutes = BASE_MINUTES[rec.habitId] || 15;
        monthMap.set(day, (monthMap.get(day) || 0) + minutes);
      });
      const today = new Date();
      const sameMonth = sCalOff === 0;
      let monthMinutes = 0;
      for (let i = 0; i < fd; i++) {
        const c = document.createElement('div');
        c.className = 'cell';
        c.style.opacity = .35;
        wrap.appendChild(c);
      }
      for (let d = 1; d <= days; d++) {
        const c = document.createElement('div');
        c.className = 'cell';
        const dn = document.createElement('div');
        dn.className = 'dayNum';
        dn.textContent = String(d);
        c.appendChild(dn);
        const minutes = monthMap.get(d) || 0;
        if (minutes > 0) {
          const mark = document.createElement('div');
          mark.className = 'seedMark';
          mark.textContent = 'ğŸ§‘â€ğŸŒ¾';
          c.appendChild(mark);
          const dur = document.createElement('div');
          dur.className = 'dur';
          dur.textContent = m2txtShort(minutes);
          c.appendChild(dur);
          monthMinutes += minutes;
        }
        if (sameMonth && d === today.getDate()) {
          c.style.outline = `2px solid ${getComputedStyle(document.documentElement).getPropertyValue('--green')}`;
        }
        c.onclick = () => {
          const b = new Date();
          b.setDate(1);
          b.setMonth(b.getMonth() + sCalOff);
          const tgt = new Date(b.getFullYear(), b.getMonth(), d);
          const now = new Date();
          now.setHours(0, 0, 0, 0);
          const targetOff = Math.round((tgt - now) / 86400000);
          dayOff = clampDayOff(targetOff);
          showHome();
          renderCards();
          renderDateBar();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        };
        wrap.appendChild(c);
      }
      $("#sMonthLabel").textContent = `${months[m]} ${y}  ğŸ§‘â€ğŸŒ¾${m2txt(round15(monthMinutes))}`;
    }
    $("#sPrevMonth").onclick = () => { sCalOff--; renderSpaceCalendar(); };
    $("#sNextMonth").onclick = () => { sCalOff++; renderSpaceCalendar(); };
    $("#sCalWho").addEventListener('change', renderSpaceCalendar);
    function getVisibleSpaces() {
      const base = allowedSpaces.length ? allowedSpaces : Object.keys(SPACES);
      const order = ['E8D3FS', 'AS50CI', 'D0PWE3', 'WS32D7', 'SR3S0D', 'PD03XZ'];
      const list = [];
      order.forEach(id => { if (base.includes(id) && !list.includes(id)) list.push(id) });
      base.forEach(id => { if (!list.includes(id)) list.push(id) });
      return list;
    }

    /* SÃ©lecteur dâ€™espace */
    function updSel() {
      const sel = $("#spaceSel"); sel.innerHTML = '';
      const ordered = getVisibleSpaces();
      if (ordered.length === 0) {
        const placeholder = document.createElement('option');
        placeholder.value = ''; placeholder.textContent = 'â€” Aucun jardin';
        sel.appendChild(placeholder);
        sel.disabled = true;
        return;
      }
      sel.disabled = false;
      ordered.forEach(id => {
        const o = document.createElement('option');
        o.value = id;
        const spaceEntry = SPACES[id];
        const memberKey = getCurrentSpaceMemberKey(spaceEntry);
        const memberName = getSpaceMemberLabel(spaceEntry, memberKey);
        const displayName = ((isPersonalSpaceType(spaceEntry)
          ? memberName
          : (spaceEntry.label || '').trim() || memberName) || '').trim();
        const pseudo = (spaceEntry.pseudo || currentProfile?.pseudo || '').trim();
        const label = displayName || pseudo || 'â€”';
        o.textContent = label;
        sel.appendChild(o);
      });
      if (!ordered.includes(spaceId) || !SPACES[spaceId]) spaceId = ordered[0];
      sel.value = spaceId;
      updateInviteGardenPseudo();
    }
    const selSpace = $("#spaceSel"); selSpace.addEventListener('change', () => { spaceId = selSpace.value; renderCards(); showHome(); updateInviteGardenPseudo(); });
    $("#openSpace").onclick = () => {
      const isSpaceActive = !!$("#space")?.classList.contains('active');
      if (isSpaceActive) {
        showHome();
        return;
      }
      openSpacePage();
    };
    $("#backFromSpace").onclick = showHome;

    /* Modales */
    const mAdd = $("#modalAdd"), mHabit = $("#modalHabit"), mInvite = $("#modalInvite"), mGarden = $("#modalGarden"), mJoin = $("#modalJoin"), mProfileSetup = $("#modalProfileSetup");
    const joinNameInput = $("#joinName");
    const joinPseudoInput = $("#joinPseudo");
    const joinStatus = $("#joinStatus");
    const joinSpaceBtn = $("#joinSpaceBtn");
    const inviteGardenPseudo = $("#inviteGardenPseudo");
    const habitBackBtn = mHabit?.querySelector('.menu-back');
    const closeHabitBtn = $("#closeHabit");
    const deleteAccountBtn = $("#deleteAccountBtn");
    const profileModeSelector = $("#profileModeSelector");
    const profileNameField = $("#profileNameField");
    const profileNameInput = $("#profileNameInput");
    const profilePseudoField = $("#profilePseudoField");
    const profilePseudoInput = $("#profilePseudoInput");
    const profilePseudoRefresh = $("#profilePseudoRefresh");
    const profileModeSetupHint = $("#profileModeSetupHint");
    const profileSetupContinue = $("#profileSetupContinue");
    let habitModalContext = 'menu';
    const open = m => m.classList.add('on'), close = m => m.classList.remove('on');
    let spacesInitialized = false;
    let habitWizardStep = 1;
    let pendingGardenPseudo = '';
    const prefsTipsSelect = $("#prefsTipsDisplayMode");
    function updateHabitModalControls() {
      if (closeHabitBtn) {
        closeHabitBtn.classList.remove('hide');
        closeHabitBtn.disabled = false;
      }
    }
    function openHabitFlow(context = 'menu') {
      habitModalContext = context;
      updateHabitModalControls();
      step1();
      open(mHabit);
    }
    inviteGardenPseudo?.addEventListener('click', () => {
      if (!inviteGardenPseudo.value) return;
      inviteGardenPseudo.select();
      copyText(inviteGardenPseudo.value);
    });
    $("#addBtn").onclick = () => { maybeTogglePrivateAdd(true); };
    $("#closeAdd").onclick = () => {
      if (allowedSpaces.length === 0) return;
      pendingAddModalTarget = null;
      close(mAdd);
    };
    async function maybeTogglePrivateAdd(forceOpen = false) {
      if (currentProfile?.email && !currentProfile?.guest) {
        await refreshOwnedSpaces(currentProfile);
      }
      if (!spacesInitialized && !forceOpen) return;
      if (forceOpen) {
        open(mAdd);
      }
      updateAddModalOptions();
    }
    document.querySelectorAll('.menu-back').forEach(btn => {
      btn.addEventListener('click', () => {
        const modal = btn.closest('.modal');
        if (modal === mHabit) {
          if (habitWizardStep === 2) {
            step1();
            return;
          }
          if (habitModalContext === 'creation') {
            close(mHabit);
            open(mGarden);
            return;
          }
        }
        if (modal) close(modal);
        maybeTogglePrivateAdd(true);
      });
    });
    async function showQuitModal() {
      const sp = getSpace();
      if (!sp) return;
      const isOwner = isCurrentSpaceAdmin();
      const prompt = isOwner
        ? 'Supprimer ce jardin fermera lâ€™espace pour tout le monde. Continuer ?'
        : 'Quitter le jardin supprime tes activitÃ©s personnelles. Continuer ?';
      if (!confirm(prompt)) return;
      if (isOwner) {
        await deleteCurrentSpace();
      } else {
        await leaveCurrentSpace();
      }
    }
    $("#addHabit").onclick = () => { close(mAdd); openHabitFlow('menu'); }
    $("#inviteFriend").onclick = () => {
      if (!requireAdmin('inviter un jardinier')) return;
      close(mAdd);
      openInvite();
    };
    function openInvite() { updateInviteGardenPseudo(); renderInviteList(); open(mInvite); }
    async function updateInviteGardenPseudo() {
      if (!inviteGardenPseudo) return;
      const targetSpace = spaceId;
      if (!targetSpace) {
        inviteGardenPseudo.value = '';
        return;
      }
      await ensureSpaceHasPseudo(targetSpace);
      if (spaceId !== targetSpace) return;
      const sp = getSpace();
      inviteGardenPseudo.value = sp?.pseudo || '';
    }
    function openJoinModal() {
      setJoinStatus('', false);
      const defaultName = pendingInviteInfo?.invitedName || getLastMemberName() || currentProfile?.name || '';
      if (joinNameInput) joinNameInput.value = defaultName;
      if (joinPseudoInput) joinPseudoInput.value = '';
      setJoinDescription('');
      lastPreviewedPseudo = '';
      open(mJoin);
    }
    function syncSpacePreferenceControls() {
      if (prefsTipsSelect) {
        prefsTipsSelect.value = getTipsDisplayMode();
      }
    }
    prefsTipsSelect?.addEventListener('change', async () => {
      const mode = prefsTipsSelect.value || 'auto';
      await updateUserTipsDisplayMode(mode);
      renderCards();
    });
    syncSpacePreferenceControls();
    function setJoinStatus(message, isError = true) {
      if (!joinStatus) return;
      joinStatus.textContent = message;
      joinStatus.style.color = isError ? '#d33' : '#2a7a57';
    }
    function setJoinDescription(text) {
      if (!joinSpaceDesc) return;
      joinSpaceDesc.textContent = text || '';
    }
    let lastPreviewedPseudo = '';
    async function previewJoinSpace(pseudo) {
      if (!pseudo) {
        setJoinDescription('');
        return;
      }
      lastPreviewedPseudo = pseudo;
      const data = await findSpaceByPseudo(pseudo);
      if (lastPreviewedPseudo !== pseudo) return;
      setJoinDescription((data?.desc || data?.description || '').trim());
    }
    let pendingAddModalTarget = null;
    const finishPendingAddModal = (target) => {
      if (pendingAddModalTarget !== target) return;
      pendingAddModalTarget = null;
      if (target === 'join') {
        openJoinModal();
      } else if (target === 'create') {
        openGardenFlow();
      }
    };
    const requestAddModalTransition = (target) => {
      pendingAddModalTarget = target;
      close(mAdd);
      setTimeout(() => finishPendingAddModal(target), 20);
    };
    const addModal = $("#modalAdd");
    addModal?.addEventListener('click', async (event) => {
      const opt = event.target.closest('.opt');
      if (!opt || opt.dataset.disabled === '1') return;
      pendingAddModalTarget = null;
      if (opt.id === 'menuLogin') {
        close(mAdd);
        showAuthOverlay(true);
        return;
      }
      if (opt.id === 'menuLogout') {
        if (!currentProfile?.email) return;
        await HABITU_FIREBASE_AUTH.signOut();
        close(mAdd);
        return;
      }
      if (opt.id === 'createGarden') {
        requestAddModalTransition('create');
        return;
      }
      if (opt.id === 'joinGarden') {
        requestAddModalTransition('join');
      }
    });
    const gardenNameInput = $("#gardenNameInput");
    const createGardenBtn = $("#createGardenBtn");
    const gardenStatus = $("#gardenStatus");
    const gardenPseudoInput = $("#gardenPseudoInput");
    const authMessage = $("#authMessage");
    const inviteName = $("#inviteName");
    const invitePseudoInput = $("#invitePseudo");
    const inviteList = $("#inviteList");
    const addMemberByPseudoBtn = $("#addMemberByPseudo");
    const authSpaceDesc = $("#authSpaceDesc");
    const joinSpaceDesc = $("#joinSpaceDesc");
    const installAppOpt = $("#installApp");
    const menuAddHabit = $("#addHabit");
    const menuInviteFriend = $("#inviteFriend");
    const menuCreateGarden = $("#createGarden");
    const menuLoginOpt = $("#menuLogin");
    const menuLogoutOpt = $("#menuLogout");
    function updateAddModalOptions() {
      const hasSpaces = allowedSpaces.length > 0;
      const isAuthenticated = !!currentProfile?.email;
      const ownedCount = countOwnedGardens(currentProfile);
      const showSupportOptions = hasSpaces;
      const currentSpace = getSpace();
      const hideInviteForIndividual = !!currentSpace && isPersonalSpaceType(currentSpace);
      if (menuCreateGarden) {
        const subtitle = menuCreateGarden.querySelector('.subtitle');
        if (subtitle) {
          subtitle.textContent = 'Nouvel espace partagÃ©';
        }
      }
      if (menuAddHabit) {
        menuAddHabit.classList.toggle('hide', !showSupportOptions);
      }
      if (menuInviteFriend) {
        menuInviteFriend.classList.toggle('hide', !showSupportOptions || hideInviteForIndividual);
      }
      if (menuLoginOpt) {
        menuLoginOpt.classList.toggle('hide', isAuthenticated);
      }
      if (menuLogoutOpt) {
        menuLogoutOpt.classList.toggle('hide', !isAuthenticated);
      }
      const locked = !hasSpaces;
      document.body.classList.toggle('no-space', locked);
      const closeAddBtnLocal = $("#closeAdd");
      if (closeAddBtnLocal) {
        closeAddBtnLocal.classList.toggle('hide', locked);
      }
    }
    async function regenerateProfilePseudo({ showNotification = true } = {}) {
      if (!currentProfile) return null;
      const candidate = await generateUniquePseudo();
      if (!candidate) return null;
      await updateUserPseudo(candidate);
      if (showNotification) {
        showToast('Pseudo rÃ©gÃ©nÃ©rÃ©.', { type: 'success' });
      }
      return candidate;
    }
    async function ensureProfilePseudo() {
      if (!currentProfile) return null;
      if (currentProfile.pseudo) return currentProfile.pseudo;
      return regenerateProfilePseudo({ showNotification: false });
    }
    async function createPersonalSpace() {
      if (!currentProfile) return;
      await ensureProfileSetup();
      await ensureProfilePseudo();
      const normalizedEmail = normalizeEmail(currentProfile.email);
      const ownerId = currentProfile.uid || '';
      const ownerLabel = (currentProfile.name || userName || 'Moi').trim() || 'Moi';
      const pseudo = currentProfile.pseudo || ownerLabel;
      if (ownerId) {
        const existingSpace = await fetchPersonalSpaceForOwner(ownerId);
        if (existingSpace) {
          const existingId = existingSpace.id;
          SPACES[existingId] = {
            ...(SPACES[existingId] || {}),
            ...existingSpace,
            ch: SPACES[existingId]?.ch || []
          };
          spaceId = existingId;
          userName = ownerLabel;
          setLastMemberName(ownerLabel);
          allowedSpaces = [...new Set([...allowedSpaces, existingId])];
          await Promise.all([
            ensureSpaceHasPseudo(existingId),
            loadHabitsForSpace(existingId),
            loadActivitiesForSpace(existingId)
          ]);
          spacesInitialized = true;
          updSel();
          renderCards();
          maybeTogglePrivateAdd();
          return existingId;
        }
      }
      const id = generateSpaceId();
      const members = normalizedEmail ? [normalizedEmail] : [];
      const memberSettings = {};
      if (normalizedEmail) {
        memberSettings[normalizeMemberKey(normalizedEmail)] = { name: ownerLabel };
      }
      const spaceEntry = {
        emoji: 'ğŸ‘¤',
        label: pseudo,
        type: 'individual',
        habitMode: 'libre',
        ch: [],
        ownerId: ownerId || null,
        members,
        createdAt: new Date(),
        editorRights: 'admin',
        memberSettings,
        pseudo,
        pseudoNormalized: normalizeSpacePseudo(pseudo)
      };
      SPACES[id] = spaceEntry;
      spaceId = id;
      userName = ownerLabel;
      setLastMemberName(ownerLabel);
      allowedSpaces = [...new Set([...allowedSpaces, id])];
      const defaultHabitSource = LIBRARY_HABITS.find(habit => String(habit.id) === '1' || habit.id === 1);
      let defaultHabit = null;
      if (defaultHabitSource) {
        defaultHabit = buildHabitPayload(spaceEntry, defaultHabitSource);
        spaceEntry.ch.push(defaultHabit);
      }
      const payload = {
        ...spaceEntry,
        createdBy: normalizedEmail || null,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      await persistSpaceDoc(id, payload);
      if (defaultHabit) {
        await persistHabit(id, defaultHabit);
      }
      await loadHabitsForSpace(id);
      await loadActivitiesForSpace(id);
      spacesInitialized = true;
      updSel();
      renderCards();
      maybeTogglePrivateAdd();
      updateAddModalOptions();
      if (pendingHabitModalAfterSetup) {
        pendingHabitModalAfterSetup = false;
        setTimeout(() => openHabitFlow('creation'), 32);
      }
      showHome();
    }
    let profileSetupPromise = null;
    let profileSetupResolver = null;

    function shouldPromptProfileSetup() {
      const seen = safeStorageGet(STORAGE_PROFILE_SETUP_KEY);
      return seen !== '1';
    }
    function markProfileSetupDone() {
      safeStorageSet(STORAGE_PROFILE_SETUP_KEY, '1');
    }
    function updateProfileSetupLocalOption() {
      if (!profileModeSelector) return;
      const localOption = profileModeSelector.querySelector('option[value="local"]');
      if (!localOption) return;
      const hideLocal = !!currentProfile?.email;
      localOption.hidden = hideLocal;
      localOption.disabled = hideLocal;
    }
    function updateProfileSetupFields() {
      if (!profileModeSelector) return;
      const mode = profileModeSelector.value || getProfileMode();
      const showExtras = mode !== 'local';
      if (profileNameField) profileNameField.classList.toggle('hide', !showExtras);
      if (profilePseudoField) profilePseudoField.classList.toggle('hide', !showExtras);
      if (profileModeSetupHint) {
        const info = PROFILE_MODE_INFO[mode] || PROFILE_MODE_INFO[getProfileMode()];
        profileModeSetupHint.textContent = info?.summary || '';
      }
    }
    async function ensureProfilePseudoInput(force = false) {
      if (!profilePseudoInput) return '';
      let candidate = '';
      if (!force) {
        candidate = (profilePseudoInput.value || '').trim() || (currentProfile?.pseudo || '').trim();
      }
      if (!candidate || force) {
        candidate = await generateUniquePseudo();
      }
      if (candidate) {
        profilePseudoInput.value = candidate;
      }
      return candidate;
    }
    async function openProfileSetupModal() {
      updateProfileSetupLocalOption();
      if (profileModeSelector) {
        profileModeSelector.value = getProfileMode();
      }
      if (profileNameInput) {
        profileNameInput.value = currentProfile?.name || '';
      }
      updateProfileSetupFields();
      await ensureProfilePseudoInput();
      if (mProfileSetup) {
        open(mProfileSetup);
      }
    }
    function closeProfileSetupModal() {
      if (mProfileSetup) {
        close(mProfileSetup);
      }
    }
    let pendingHabitModalAfterSetup = false;

    async function ensureProfileSetup() {
      if (!shouldPromptProfileSetup()) return;
      if (!mProfileSetup || !profileModeSelector) return;
      if (profileSetupPromise) return profileSetupPromise;
      profileSetupPromise = new Promise(resolve => {
        profileSetupResolver = resolve;
        openProfileSetupModal().catch(err => console.warn('openProfileSetupModal', err));
      });
      return profileSetupPromise;
    }
    function finalizeProfileSetup() {
      markProfileSetupDone();
      pendingHabitModalAfterSetup = true;
      if (profileSetupResolver) {
        profileSetupResolver();
        profileSetupResolver = null;
      }
      profileSetupPromise = null;
      closeProfileSetupModal();
    }
    if (profileModeSelector && !profileModeSelector.dataset.bound) {
      profileModeSelector.addEventListener('change', updateProfileSetupFields);
      profileModeSelector.dataset.bound = '1';
    }
    if (profilePseudoRefresh) {
      profilePseudoRefresh.addEventListener('click', async () => {
        profilePseudoRefresh.disabled = true;
        try {
          const candidate = await ensureProfilePseudoInput(true);
          if (candidate) {
            persistProfile({ pseudo: candidate });
          }
        } finally {
          profilePseudoRefresh.disabled = false;
        }
      });
    }
    if (profileSetupContinue) {
      profileSetupContinue.addEventListener('click', async () => {
        if (!profileModeSelector) return;
        const selectedMode = profileModeSelector.value || DEFAULT_PROFILE_MODE;
        const nameValue = (profileNameInput?.value || '').trim();
        const pseudoValue = (profilePseudoField ? (profilePseudoInput?.value || '').trim() : '');
        try {
          if (nameValue) {
            persistProfile({ name: nameValue });
          }
          let actualPseudo = pseudoValue;
          if (!actualPseudo) {
            actualPseudo = await ensureProfilePseudoInput(true);
          }
          if (actualPseudo) {
            if (selectedMode !== 'local') {
              await updateUserPseudo(actualPseudo);
            } else {
              persistProfile({ pseudo: actualPseudo });
            }
          }
          await updateProfileMode(selectedMode);
          finalizeProfileSetup();
        } catch (err) {
          console.warn('profile setup', err);
          showToast('Impossible de sauvegarder ton profil pour lâ€™instant.', { type: 'error' });
        }
      });
    }
    const installPromptBtn = $("#installPromptBtn");
    const installPromptClose = $("#installPromptClose");
    const installPromptHelp = $("#installPromptHelp");
    const generateInviteBtn = $("#generateInvite");
    const deleteSpaceBtn = $("#deleteSpaceBtn");
    const habitGardenersBody = $("#habitGardenersBody");
    const habitGardenersEmpty = $("#habitGardenersEmpty");
    const habitGardenersHeader = $("#habitGardenersHeader");
    habitGardenersSortHeaders = habitGardenersHeader ? Array.from(habitGardenersHeader.querySelectorAll('th[data-sort]')) : [];
    habitGardenersSortHeaders.forEach(th => th.addEventListener('click', () => setHabitGardenersSort(th.dataset.sort)));
    updateHabitGardenersSortHeaders();
    createGardenBtn.onclick = createGarden;
    joinPseudoInput?.addEventListener('input', () => {
      if (!joinPseudoInput) return;
      const normalized = normalizeSpacePseudo(joinPseudoInput.value);
      if (joinPseudoInput.value !== normalized) {
        joinPseudoInput.value = normalized;
      }
      if (normalized.length >= 3) {
        previewJoinSpace(normalized);
      } else {
        setJoinDescription('');
      }
    });
    joinSpaceBtn?.addEventListener('click', joinGardenByPseudo);
    generateInviteBtn.onclick = generateInviteLink;
    addMemberByPseudoBtn?.addEventListener('click', addMemberByPseudo);
    deleteSpaceBtn?.addEventListener('click', () => deleteCurrentSpace());
    deleteAccountBtn?.addEventListener('click', handleAccountDeletion);
    installAppOpt?.addEventListener('click', () => {
      close(mAdd);
      triggerInstallPrompt('manual');
    });
    installPromptBtn?.addEventListener('click', () => triggerInstallPrompt('manual'));
    installPromptClose?.addEventListener('click', () => {
      markInstallPromptSeen();
      closeInstallPromptCard();
    });
    installPromptHelp?.addEventListener('click', () => {
      showToast('Installer donne un accÃ¨s rapide sur ton Ã©cran dâ€™accueil.', { type: 'info', duration: 5000 });
    });
    updateInstallOptionVisibility();

    function updateAuthMessage() {
      if (pendingInviteInfo) {
        const spaceName = pendingInviteInfo.gardenLabel || pendingInviteInfo.label || 'ton jardin';
        const ownerName = pendingInviteInfo.ownerName || 'un jardinier';
        authMessage.textContent = `Connecte-toi pour retrouver le jardin "${spaceName}" de ${ownerName}.`;
        if (authSpaceDesc) {
          authSpaceDesc.textContent = (pendingInviteInfo.spaceDesc || '').trim();
        }
      } else {
        authMessage.textContent = 'Connecte-toi pour retrouver tes habitudes';
        if (authSpaceDesc) {
          authSpaceDesc.textContent = '';
        }
      }
      updateAuthFormState();
    }
    refreshPendingInviteInfo().then(updateAuthMessage);

    async function refreshGardenPseudoPreview() {
      if (!gardenStatus) return;
      gardenStatus.textContent = 'GÃ©nÃ©ration du pseudo du jardinâ€¦';
      try {
        const candidate = await generateUniqueGardenPseudo();
        pendingGardenPseudo = candidate || '';
        if (candidate) {
          gardenStatus.textContent = `Pseudo du jardin : ${candidate}`;
          if (gardenPseudoInput) {
            gardenPseudoInput.value = candidate;
          }
        } else {
          gardenStatus.textContent = 'Impossible de gÃ©nÃ©rer un pseudo pour lâ€™instant.';
        }
      } catch (err) {
        console.warn('refreshGardenPseudoPreview', err);
        pendingGardenPseudo = '';
        gardenStatus.textContent = 'Impossible de gÃ©nÃ©rer un pseudo pour lâ€™instant.';
      }
    }

    function openGardenFlow() {
      gardenNameInput.value = '';
      gardenStatus.textContent = '';
      pendingGardenPseudo = '';
      if (gardenPseudoInput) {
        gardenPseudoInput.value = '';
      }
      refreshGardenPseudoPreview();
      open(mGarden);
    }

    async function createGarden() {
      if (!currentProfile) {
        persistProfile({ name: userName || 'Moi', guest: true });
      }
      if (!currentProfile?.guest) {
        await refreshOwnedSpaces(currentProfile);
      }
      const profile = GARDEN_TYPES[0];
      const title = (gardenNameInput.value || profile.label).trim() || profile.label;
      const habitMode = 'commun';
      const id = generateSpaceId();
      const ownerEmail = normalizeEmail(currentProfile?.email || '');
      const ownerId = (currentProfile?.uid || '').trim();
      const memberSet = new Set();
      if (ownerEmail) memberSet.add(ownerEmail);
      if (ownerId) memberSet.add(ownerId);
      const memberList = sanitizeSpaceMembers(Array.from(memberSet));
      const ownerLabel = (currentProfile?.name || userName || 'Moi').trim() || 'Moi';
      const memberSettings = {};
      if (ownerEmail) {
        memberSettings[normalizeMemberKey(ownerEmail)] = { name: ownerLabel };
      }
      if (ownerId) {
        memberSettings[normalizeMemberKey(ownerId)] = { name: ownerLabel };
      }
      let pseudo = '';
      const requestedPseudoRaw = (gardenPseudoInput?.value || '').trim();
      if (requestedPseudoRaw) {
        const sanitizedRequest = normalizeSpacePseudo(requestedPseudoRaw);
        if (sanitizedRequest) {
          pseudo = sanitizedRequest;
          if (gardenPseudoInput) {
            gardenPseudoInput.value = sanitizedRequest;
          }
        }
      }
      if (!pseudo) {
        pseudo = pendingGardenPseudo || await generateUniqueGardenPseudo();
      }
      if (!pseudo) {
        const fallbackBase = normalizeSpacePseudo(title) || 'jardin';
        pseudo = `${fallbackBase}${Math.floor(Math.random() * 90 + 10)}`;
      }
      const pseudoNormalized = normalizeSpacePseudo(pseudo) || pseudo;
      pendingGardenPseudo = '';
      if (gardenPseudoInput) {
        gardenPseudoInput.value = pseudo;
      }

      SPACES[id] = {
        emoji: profile.emoji,
        label: title,
        type: profile.type,
        habitMode,
        code: accessCode,
        ch: [],
        ownerId: ownerId || null,
        members: memberList,
        createdAt: new Date(),
        editorRights: 'admin',
        memberSettings,
        pseudo,
        pseudoNormalized
      };
      spaceId = id;
      userName = ownerLabel;
      setLastMemberName(ownerLabel);
      allowedSpaces = [...new Set([...allowedSpaces, id])];
      if (currentProfile?.guest) {
        addGuestSpace(id);
      }
      const creationPayload = {
        members: memberList,
        createdBy: currentProfile?.email || null,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        memberSettings
      };
      gardenStatus.textContent = 'Ajoute quelques habitudes pour dÃ©marrer ton jardin.';
      await persistSpaceDoc(id, creationPayload);
      await loadActivitiesForSpace(id);
      updSel();
      renderCards();
      close(mGarden);
      openHabitFlow('creation');
    }
    function renderInviteList() {
      inviteList.innerHTML = '';
      const entries = Object.values(INVITE_CACHE).sort((a, b) => (b.created || 0) - (a.created || 0));
      if (!entries.length) {
        const help = document.createElement('div');
        help.className = 'miniInfo';
        help.textContent = 'Aucune invitation active pour lâ€™instant.';
        inviteList.appendChild(help);
        return;
      }
      entries.forEach((invite) => {
        const token = invite.token;
        const row = document.createElement('div');
        row.className = 'invite-row';
        const nameEl = document.createElement('div');
        nameEl.className = 'invite-name';
        nameEl.textContent = invite.invitedName;
        const link = `${inviteBaseUrl()}?invite=${token}`;
        const linkWrapper = document.createElement('div');
        linkWrapper.className = 'invite-link-row';
        const icon = document.createElement('span');
        icon.textContent = 'ğŸ”—';
        icon.style.userSelect = 'none';
        icon.style.cursor = 'pointer';
        const linkInput = document.createElement('input');
        linkInput.type = 'text';
        linkInput.value = link;
        linkInput.readOnly = true;
        linkInput.className = 'invite-link-input';
        linkInput.addEventListener('click', () => {
          linkInput.select();
          copyText(link);
        });
        linkInput.addEventListener('focus', () => linkInput.select());
        icon.addEventListener('click', () => {
          linkInput.select();
          copyText(link);
        });
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn copyOnly';
        removeBtn.title = 'Supprimer';
        removeBtn.textContent = 'ğŸ—‘ï¸';
        removeBtn.onclick = async () => {
          await deleteInviteDoc(token);
          renderInviteList();
          showToast('Invitation supprimÃ©e.', { type: 'info' });
        };
        linkWrapper.append(icon, linkInput, removeBtn);
        row.append(nameEl, linkWrapper);
        inviteList.appendChild(row);
      });
    }

    async function findUserProfileByPseudo(pseudo) {
      if (!HABITU_FIREBASE_DB || !pseudo) return null;
      const sanitizedPseudo = sanitizePseudo(pseudo);
      if (!sanitizedPseudo) return null;
      const normalized = sanitizedPseudo.toLowerCase();
      const queryBy = async (field, value) => {
        try {
          const snapshot = await HABITU_FIREBASE_DB.collection('users')
            .where(field, '==', value)
            .limit(1)
            .get();
          if (!snapshot || snapshot.empty) return null;
          const doc = snapshot.docs[0];
          return { uid: doc.id, ...doc.data() };
        } catch (err) {
          console.warn('findUserProfileByPseudo', field, err);
          return null;
        }
      };
      if (normalized) {
        const normalizedMatch = await queryBy('pseudoNormalized', normalized);
        if (normalizedMatch) return normalizedMatch;
      }
      return await queryBy('pseudo', sanitizedPseudo);
    }

    async function addMemberByPseudo() {
      if (!requireAdmin('ajouter un jardinier')) return;
      const rawPseudo = (invitePseudoInput?.value || '').trim();
      if (!rawPseudo) { showToast('Entre le pseudo du jardinier.', { type: 'error' }); return; }
      if (!spaceId) { showToast('SÃ©lectionne dâ€™abord un jardin.', { type: 'error' }); return; }
      const sanitizedInput = sanitizePseudo(rawPseudo);
      if (!sanitizedInput) { showToast('Ce pseudo nâ€™est pas valide.', { type: 'error' }); return; }
      if (addMemberByPseudoBtn) {
        addMemberByPseudoBtn.disabled = true;
      }
      try {
        const profile = await findUserProfileByPseudo(sanitizedInput);
        if (!profile?.email) {
          showToast('Aucun jardinier trouvÃ© pour ce pseudo.', { type: 'error' });
          return;
        }
        if (isMemberInSpace(spaceId, profile.email) || (profile.uid && isMemberInSpace(spaceId, profile.uid))) {
          showToast('Ce jardinier fait dÃ©jÃ  partie du jardin.', { type: 'info' });
          return;
        }
        await joinSpace(spaceId, profile.email, { name: profile.name || profile.pseudo });
        showToast('Jardinier ajoutÃ© !', { type: 'success' });
        if (invitePseudoInput) {
          invitePseudoInput.value = '';
        }
      } catch (err) {
        console.warn('addMemberByPseudo', err);
        showToast('Impossible dâ€™ajouter ce jardinier pour lâ€™instant.', { type: 'error' });
      } finally {
        if (addMemberByPseudoBtn) {
          addMemberByPseudoBtn.disabled = false;
        }
      }
    }

    async function generateInviteLink() {
      if (!requireAdmin('gÃ©nÃ©rer une invitation')) return;
      const name = (inviteName.value || '').trim();
      if (!name) { showToast('Entre un prÃ©nom.', { type: 'error' }); return; }
      if (!spaceId) { showToast('SÃ©lectionne dâ€™abord un jardin.', { type: 'error' }); return; }
      if (Object.values(INVITE_CACHE).some(inv => (inv.invitedName || '').toLowerCase() === name.toLowerCase())) {
        showToast('Ce prÃ©nom est dÃ©jÃ  utilisÃ© pour une invitation.', { type: 'error' });
        return;
      }
      await ensureSpaceHasPseudo(spaceId);
      const token = genInviteToken();
      const link = `${inviteBaseUrl()}?invite=${token}`;
      const ownerName = currentProfile?.name || userName || 'Un jardinier';
      const inviteData = {
        ownerName,
        invitedName: name,
        spaceId,
        spacePseudo: SPACES[spaceId]?.pseudo || '',
        spaceDesc: (SPACES[spaceId]?.desc || '').trim(),
        gardenLabel: SPACES[spaceId]?.label || 'ton jardin',
        created: Date.now(),
        ownerId: currentProfile?.uid
      };
      await persistInviteDoc(token, inviteData);
      INVITE_CACHE[token] = { token, ...inviteData };
      showToast('Lien gÃ©nÃ©rÃ© !', { type: 'success' });
      renderInviteList();
      copyText(link);
    }

    async function findSpaceByPseudo(pseudo) {
      if (!HABITU_FIREBASE_DB || !pseudo) return null;
      const normalizedPseudo = normalizeSpacePseudo(pseudo);
      const queryBy = async (field, value) => {
        const snapshot = await HABITU_FIREBASE_DB.collection('spaces')
          .where(field, '==', value)
          .limit(1)
          .get();
        return snapshot.empty ? null : snapshot.docs[0];
      };
      try {
        let doc = normalizedPseudo ? await queryBy('pseudoNormalized', normalizedPseudo) : null;
        if (!doc) {
          doc = await queryBy('pseudo', pseudo);
        }
        if (!doc) {
          const fallbackCode = pseudo.toUpperCase();
          doc = await queryBy('code', fallbackCode);
        }
        if (!doc) return null;
        const raw = doc.data() || {};
        const members = Array.isArray(raw.members) ? raw.members : [];
        return {
          id: doc.id,
          ...raw,
          members,
          memberIdByEmail: raw.memberIdByEmail || {},
          createdAt: timestampToDate(raw.createdAt)
        };
      } catch (err) {
        console.warn('findSpaceByPseudo', err);
        return null;
      }
    }

    async function joinGardenByPseudo() {
      if (!joinSpaceBtn) return;
      const name = (joinNameInput?.value || '').trim();
      if (!name) { setJoinStatus('Entre ton prÃ©nom.', true); return; }
      const pseudo = normalizeSpacePseudo(joinPseudoInput?.value || '');
      if (!pseudo) { setJoinStatus('Entre le pseudo du jardin.', true); return; }
      joinSpaceBtn.disabled = true;
      try {
        const spaceData = await findSpaceByPseudo(pseudo);
        if (!spaceData) { setJoinStatus('Aucun jardin ne correspond Ã  ce pseudo.', true); return; }
        if (allowedSpaces.includes(spaceData.id)) { setJoinStatus('Tu fais dÃ©jÃ  partie de ce jardin.', true); return; }
        SPACES[spaceData.id] = { ...(SPACES[spaceData.id] || {}), ...spaceData, members: spaceData.members || [] };
        if (currentProfile?.email) {
          await joinSpace(spaceData.id, currentProfile.email, { name });
        } else {
          addGuestSpace(spaceData.id);
        }
        allowedSpaces = [...new Set([...allowedSpaces, spaceData.id])];
        spaceId = spaceData.id;
        await Promise.all([loadHabitsForSpace(spaceId), loadActivitiesForSpace(spaceId)]);
        await ensureSpaceHasPseudo(spaceId);
        updateInviteGardenPseudo();
        updAll();
        showHome();
        setJoinStatus('Jardin rejoint !', false);
        setJoinDescription((spaceData.desc || spaceData.description || '').trim());
        close(mJoin);
      } catch (err) {
        console.warn('joinGardenByPseudo', err);
        setJoinStatus('Impossible de rejoindre ce jardin pour lâ€™instant.', true);
      } finally {
        joinSpaceBtn.disabled = false;
      }
    }

    function copyText(value) {
      if (!value) return;
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(value).then(() => {
          showToast('Lien copiÃ© !', { type: 'success' });
        }).catch(() => {
          showToast('Copie manuelle : sÃ©lectionne et copie.', { type: 'error' });
        });
      } else {
        showToast('Copie manuelle : sÃ©lectionne et copie.', { type: 'error' });
      }
    }

    renderInviteList();

    /* Wizard bibliothÃ¨que multi-sÃ©lection */
    function matchesHabitContext(habit, contextTags) {
      if (!contextTags || !contextTags.length) return true;
      return (habit.contexts || []).some(ctx => contextTags.includes(ctx));
    }
    function matchesHabitNeeds(habit, needTags) {
      if (!needTags || !needTags.length) return false;
      return (habit.needs || []).some(need => needTags.includes(need));
    }
    function matchesHabitSelection(habit, contextTags, needTags) {
      const hasContext = !!(contextTags && contextTags.length);
      const hasNeed = !!(needTags && needTags.length);
      if (!hasContext && !hasNeed) return true;
      if (hasContext && matchesHabitContext(habit, contextTags)) return true;
      if (hasNeed && matchesHabitNeeds(habit, needTags)) return true;
      return false;
    }
    function matchesHabitMode(habit, modeKey) {
      if (!modeKey) return true;
      const modeInfo = MODE_META[modeKey];
      if (!modeInfo) return true;
      const habitTarget = (habit.target || 'group').toString().toLowerCase();
      return habitTarget === (modeInfo.target || 'group').toLowerCase();
    }
    function countMatchingHabits(contextTags, needTags, modeKey) {
      return LIBRARY_HABITS.filter(habit =>
        matchesHabitSelection(habit, contextTags, needTags) &&
        matchesHabitMode(habit, modeKey)
      ).length;
    }
    function step1() {
      const root = $("#step1");
      const step2 = $("#step2");
      $("#habitTitle").textContent = "Nouvelle(s) habitude(s)";
      if (step2) step2.style.display = 'none';
      if (!root) return;
      root.style.display = 'grid';
      root.innerHTML = '';

      habitWizardStep = 1;
      if (!LIBRARY_HABITS.length) {
        const empty = document.createElement('div');
        empty.className = 'miniInfo';
        empty.textContent = "La bibliothÃ¨que d'habitudes est momentanÃ©ment indisponible.";
        root.appendChild(empty);
        return;
      }

      const actions = document.createElement('div');
      actions.className = 'habit-actions';
      const nextBtn = document.createElement('button');
      nextBtn.type = 'button';
      nextBtn.className = 'btn primary';
      nextBtn.textContent = 'Voir les 0 habitudes';

      let contextSection;
      let needSection;
      function updateNextLabel() {
        const totalMatching = countMatchingHabits(contextSection?.selected || [], needSection?.selected || [], null);
        nextBtn.textContent = `Voir les ${totalMatching} habitudes`;
      }

      contextSection = buildTagSection('OÃ¹ ?', LIBRARY_CONTEXTS, updateNextLabel, 'context');
      needSection = buildTagSection('Pourquoi ?', LIBRARY_NEEDS, updateNextLabel, 'need');

      nextBtn.addEventListener('click', () => {
        renderHabitSuggestions([...contextSection.selected], [...needSection.selected]);
      });

      actions.appendChild(nextBtn);
      root.appendChild(contextSection.container);
      root.appendChild(needSection.container);
      root.appendChild(actions);
      updateNextLabel();
    }

    function buildTagSection(title, tags, onUpdate, type) {
      const container = document.createElement('div');
      container.className = 'tag-section';
      const titleRow = document.createElement('div');
      titleRow.className = 'field';
      const labelEl = document.createElement('label');
      labelEl.innerHTML = `<b>${title}</b>`;
      titleRow.appendChild(labelEl);
      container.appendChild(titleRow);

      if (!tags.length) {
        const empty = document.createElement('div');
        empty.className = 'miniInfo';
        empty.textContent = `Aucune suggestion de ${title.toLowerCase()} pour l'instant.`;
        container.appendChild(empty);
        return { container, selected: [] };
      }

      const grid = document.createElement('div');
      grid.className = 'tag-grid';
      container.appendChild(grid);

      const selected = [];
      tags.forEach(tag => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tag';
        btn.textContent = formatTagLabel(tag, type);
        btn.addEventListener('click', () => {
          const idx = selected.indexOf(tag);
          if (idx >= 0) {
            selected.splice(idx, 1);
            btn.classList.remove('active');
            if (typeof onUpdate === 'function') onUpdate();
            return;
          }
          selected.push(tag);
          btn.classList.add('active');
          if (typeof onUpdate === 'function') onUpdate();
        });
        grid.appendChild(btn);
      });

      return { container, selected };
    }

    function renderHabitSuggestions(contextTags, needTags, modeFilter = null) {
      const step1El = $("#step1");
      const root = $("#step2");
      const titleEl = $("#habitTitle");
      if (!root) return;
      const contexts = Array.isArray(contextTags) ? contextTags.slice() : [];
      const needs = Array.isArray(needTags) ? needTags.slice() : [];
      if (titleEl) {
        titleEl.textContent = 'Habitudes suggÃ©rÃ©es';
      }
      if (step1El) step1El.style.display = 'none';
      root.style.display = 'grid';
      root.innerHTML = '';
      habitWizardStep = 2;
      const spaceHabits = new Set((getSpace()?.ch || []).map(habit => String(habit.id)));
      const matchingHabits = LIBRARY_HABITS
        .filter(habit => matchesHabitSelection(habit, contexts, needs))
        .filter(habit => matchesHabitMode(habit, modeFilter))
        .filter(habit => !spaceHabits.has(String(habit.id)))
        .sort((a, b) => (a.title || '').localeCompare(b.title || '', 'fr'));
      const orderedHabits = matchingHabits;
      const selection = new Set();
      const suggestionMap = new Map(matchingHabits.map(habit => [habit.id, habit]));
      const addSelectionBtn = document.createElement('button');
      addSelectionBtn.type = 'button';
      addSelectionBtn.className = 'btn primary habit-actions__add';
      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.className = 'btn primary';
      closeBtn.textContent = 'Terminer';
      closeBtn.addEventListener('click', () => close(mHabit));
      const controls = document.createElement('div');
      controls.className = 'habit-actions footer-sticky';
      const infoWrapper = document.createElement('div');
      infoWrapper.className = 'habit-actions__info';
      const label = document.createElement('span');
      label.className = 'habit-actions__label';
      label.textContent = 'Jours souhaitÃ©s :';
      const dayWrapper = document.createElement('div');
      dayWrapper.className = 'habit-actions__days';
      const selectedWeekDays = new Set(WEEKDAY_ORDER);
      WEEKDAY_ORDER.forEach(day => {
        const dayBtn = document.createElement('button');
        dayBtn.type = 'button';
        dayBtn.className = 'habit-actions__day habit-actions__day--active';
        dayBtn.textContent = WEEKDAY_SHORT_LABELS[day] || '';
        dayBtn.dataset.day = String(day);
        dayBtn.addEventListener('click', () => {
          if (selectedWeekDays.has(day)) {
            if (selectedWeekDays.size <= 1) return;
            selectedWeekDays.delete(day);
            dayBtn.classList.remove('habit-actions__day--active');
          } else {
            selectedWeekDays.add(day);
            dayBtn.classList.add('habit-actions__day--active');
          }
          updateAddLabel();
        });
        dayWrapper.appendChild(dayBtn);
      });
      infoWrapper.append(label, dayWrapper);
      const buttonsWrap = document.createElement('div');
      buttonsWrap.style.display = 'flex';
      buttonsWrap.style.gap = '8px';
      const updateAddLabel = () => {
        const count = selection.size;
        addSelectionBtn.disabled = count === 0;
        addSelectionBtn.hidden = count === 0;
        closeBtn.hidden = count !== 0;
        addSelectionBtn.textContent = count > 0 ? `Ajouter (${count})` : 'Ajouter';
      };
      buttonsWrap.append(addSelectionBtn, closeBtn);
      controls.append(infoWrapper, buttonsWrap);

      if (!orderedHabits.length) {
        const info = document.createElement('div');
        info.className = 'miniInfo';
        info.textContent = "Aucune habitude ne correspond aux contextes sÃ©lectionnÃ©s.";
        root.appendChild(info);
      } else {
        const grid = document.createElement('div');
        grid.className = 'habit-grid';
        const renderHabitButtons = (habitList) => {
          habitList.forEach(habit => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'habit-btn';
            btn.dataset.id = habit.id;
            if (selection.has(habit.id)) {
              btn.classList.add('selected');
            }
            btn.innerHTML = `<span class="emoji">${habit.emoji || 'ğŸŒ±'}</span><span class="label">${habit.title}</span>`;
            btn.addEventListener('click', () => {
              const active = btn.classList.toggle('selected');
              if (active) selection.add(habit.id);
              else selection.delete(habit.id);
              updateAddLabel();
            });
            grid.appendChild(btn);
          });
        };
        renderHabitButtons(orderedHabits);
        root.appendChild(grid);
      }
      root.appendChild(controls);
      updateAddLabel();
      addSelectionBtn.addEventListener('click', async () => {
        if (!selection.size) return;
        const sp = getSpace();
        const persistPromises = [];
        const targetedDays = WEEKDAY_ORDER.filter(day => selectedWeekDays.has(day));
        selection.forEach(hid => {
          if (!sp) return;
          const habitId = String(hid);
          if ((sp.ch || []).some(x => String(x.id) === habitId)) return;
          const habitSource = suggestionMap.get(hid) || LIBRARY_HABITS.find(x => x.id === hid);
          if (!habitSource) return;
          const frequency = Number.isFinite(Number(habitSource.frequency)) ? Number(habitSource.frequency) : 1;
          const schedule = chooseWeekDaysForFrequency(targetedDays, frequency, habitSource.id || habitId);
          const payload = buildHabitPayload(sp, habitSource, {
            frequency,
            repeatConfig: {
              unit: 'week',
              interval: schedule.interval,
              weekDays: schedule.weekDays
            }
          });
          (sp.ch || (sp.ch = [])).push(payload);
          ensureHabit(hid);
          persistPromises.push(persistHabit(spaceId, payload));
        });
        if (!persistPromises.length) return;
        const addedCount = persistPromises.length;
        await Promise.all(persistPromises);
        renderCards();
        renderHabitSuggestions(contexts.slice(), needs.slice(), modeFilter);
        showToast(`${addedCount} habitude${addedCount > 1 ? 's' : ''} ajoutÃ©e${addedCount > 1 ? 's' : ''}`);
      });
    }

    function chooseWeekDaysForFrequency(selectedDays, frequencyValue, habitId) {
      const normalizedDays = WEEKDAY_ORDER.filter(day => (selectedDays || []).includes(day));
      const days = normalizedDays.length ? normalizedDays : WEEKDAY_ORDER.slice();
      const freqNum = Number.isFinite(Number(frequencyValue)) ? Number(frequencyValue) : 1;
      if (freqNum <= 0) {
        return { interval: 1, weekDays: days.slice() };
      }
      if (freqNum < 1) {
        const interval = Math.max(1, Math.round(1 / freqNum));
        const [singleDay] = pickRandomDay(days, habitId);
        return { interval, weekDays: singleDay !== undefined ? [singleDay] : [days[0]] };
      }
      const times = Math.min(Math.max(1, Math.round(freqNum)), days.length);
      const weekDays = pickSpacedDays(days, times);
      if (!weekDays.length) {
        return { interval: 1, weekDays: [days[0]] };
      }
      return { interval: 1, weekDays };
    }

    function pickSpacedDays(days, count) {
      if (!days.length || count <= 0) return [];
      const result = new Set();
      const length = days.length;
      for (let i = 0; i < count; i += 1) {
        const idx = Math.floor((i * length) / count);
        result.add(days[idx % length]);
      }
      return days.filter(day => result.has(day)).sort((a, b) => WEEKDAY_ORDER.indexOf(a) - WEEKDAY_ORDER.indexOf(b));
    }

    function pickRandomDay(days, seed) {
      if (!days.length) return [];
      const hash = Math.abs(hashStr(String(seed))) || 0;
      const idx = hash % days.length;
      return [days[idx]];
    }


    closeHabitBtn?.addEventListener('click', () => {
      close(mHabit);
    });
    $("#closeInvite").onclick = () => close(mInvite);

    /* Jour +/- */
    $("#prevDay").onclick = () => { dayOff = clampDayOff(dayOff - 1); renderCards(); renderDateBar(); };
    $("#nextDay").onclick = () => { dayOff = clampDayOff(dayOff + 1); renderCards(); renderDateBar(); };

    /* Lancement */
    let dayInit = false; function renderDateOnce() { if (!dayInit) { dayOff = 0; renderDateBar(); dayInit = true } }
    function updAll() { renderCards(); renderDateOnce(); updSel(); maybeTogglePrivateAdd(); updSpaceHeader() }
    const loaderOverlay = $("#loaderOverlay");
    const authOverlay = $("#authOverlay");
    const brand = $("#brand");
    const forgotPasswordLink = $("#forgotPasswordLink");
    const authForm = $("#authForm");
    const authEmailInput = $("#authEmail");
    const authPasswordInput = $("#authPassword");
    const authLoginBtn = $("#authLoginBtn");
    const authSignupBtn = $("#authSignupBtn");
    const authGuestBtn = $("#authGuestBtn");
    const resetNotice = $("#resetNotice");
    const authError = $("#authError");
    let loaderHabitTimer = null;
    authLoginBtn?.addEventListener('click', () => { if (authForm) authForm.dataset.intent = 'login'; });
    authSignupBtn?.addEventListener('click', () => { if (authForm) authForm.dataset.intent = 'signup'; });
    authGuestBtn?.addEventListener('click', () => startGuestSession());
    authForm?.addEventListener('submit', handleAuthSubmit);
    updateAuthFormState();
    updateAuthMessage();
    showLoaderOverlay();

    brand?.addEventListener('click', () => {
      dayOff = 0;
      showHome();
      renderCards();
      renderDateBar();
    });

    function clearResetNotice() {
      if (resetNotice) resetNotice.textContent = '';
    }

    function isEmailValid(input) {
      if (!input) return false;
      return input.checkValidity();
    }

    function updateAuthFormState() {
      const forceSignup = !!pendingInviteInfo;
      if (authLoginBtn) {
        authLoginBtn.disabled = forceSignup;
        authLoginBtn.title = forceSignup ? 'Tu dois crÃ©er un compte pour accepter cette invitation.' : '';
      }
    }

    async function handleAuthSubmit(event) {
      if (!authForm) return;
      event.preventDefault();
      authError.textContent = '';
      clearResetNotice();
      const forceSignup = !!pendingInviteInfo;
      const submitterAction = event.submitter?.dataset?.action;
      const fallbackIntent = authForm.dataset.intent;
      const rawIntent = submitterAction || fallbackIntent || 'login';
      const intent = forceSignup ? 'signup' : rawIntent;
      authForm.dataset.intent = '';

      if (!authEmailInput || !isEmailValid(authEmailInput)) {
        authError.textContent = 'Entre un email valide.';
        return;
      }
      const email = (authEmailInput.value || '').trim().toLowerCase();
      const password = (authPasswordInput?.value || '').trim();
      if (!password) {
        authError.textContent = intent === 'signup' ? 'Choisis un mot de passe.' : 'Entre ton mot de passe.';
        return;
      }
      if (intent === 'signup') {
        try {
          await HABITU_FIREBASE_AUTH.createUserWithEmailAndPassword(email, password);
        } catch (err) {
          authError.textContent = err.message || 'Impossible de crÃ©er le compte.';
        }
        return;
      }
      try {
        await HABITU_FIREBASE_AUTH.signInWithEmailAndPassword(email, password);
      } catch (err) {
        authError.textContent = 'Mot de passe erronÃ©.';
      }
    }

    function startLoaderAnimation() {
      if (loaderHabitTimer) return;
      refreshLoader(getLoaderMinuteSeed());
      loaderHabitTimer = setInterval(() => refreshLoader(getLoaderMinuteSeed()), LOADER_ROTATION_MS);
    }
    function stopLoaderAnimation() {
      if (loaderHabitTimer) {
        clearInterval(loaderHabitTimer);
        loaderHabitTimer = null;
      }
    }
    function showLoaderOverlay() {
      if (!loaderOverlay) return;
      loaderOverlay.classList.remove('hide');
      startLoaderAnimation();
    }
    function hideLoaderOverlay() {
      if (!loaderOverlay) return;
      loaderOverlay.classList.add('hide');
      stopLoaderAnimation();
    }

    forgotPasswordLink?.addEventListener('click', async (e) => {
      e.preventDefault();
      if (!authEmailInput || !isEmailValid(authEmailInput)) {
        resetNotice.textContent = 'Entre un email valide.';
        return;
      }
      const email = (authEmailInput.value || '').trim().toLowerCase();
      try {
        await HABITU_FIREBASE_AUTH.sendPasswordResetEmail(email);
      } catch (err) {
        // Do not surface whether the account exists.
      } finally {
        resetNotice.textContent = 'Lien de rÃ©initialisation envoyÃ© !';
      }
    });

    function hideAuthOverlay() { authOverlay.classList.add('hide') }
    function showAuthOverlay(force = false) {
      hideLoaderOverlay();
      clearResetNotice();
      if (authError) authError.textContent = '';
      authOverlay.classList.remove('hide');
    }

    async function startGuestSession() {
      if (currentProfile?.guest && HABITU_FIREBASE_AUTH?.currentUser?.isAnonymous) {
        hideAuthOverlay();
        updateAddModalOptions();
        showLoaderOverlay();
        try {
          await loadLibraryData();
        } finally {
          hideLoaderOverlay();
        }
        showHome();
        return;
      }
      try {
        await HABITU_FIREBASE_AUTH.signInAnonymously();
      } catch (err) {
        showToast('Impossible de dÃ©marrer une session invitÃ©.', { type: 'error' });
      }
    }

    async function linkGuestSpacesToEmail(email) {
      if (!email || guestSpaces.size === 0) return;
      const spaces = Array.from(guestSpaces);
      await Promise.all(spaces.map(id => joinSpace(id, email, { name: currentProfile?.name })));
      clearGuestSpaces();
    }

    async function ensureProfileName(defaultName = '') {
      const existing = (currentProfile?.name || '').trim();
      if (existing) return existing;
      const candidate = window.prompt('Quel est ton prÃ©nom ?', defaultName || 'Moi');
      const finalName = (candidate || '').trim() || defaultName || 'Moi';
      if (!finalName) return null;
      const updated = { ...(currentProfile || {}), name: finalName };
      persistProfile(updated);
      if (HABITU_FIREBASE_AUTH.currentUser) {
        try {
          await HABITU_FIREBASE_AUTH.currentUser.updateProfile({ displayName: finalName });
        } catch (err) {
          console.warn('ensureProfileName updateProfile', err);
        }
      }
      if (updated.uid) {
        await persistUserProfile({
          uid: updated.uid,
          email: updated.email,
          name: finalName,
          tipsDisplayMode: updated.tipsDisplayMode,
          pinnedHabits: updated.pinnedHabits,
          postponedHabits: updated.postponedHabits,
          forgottenHabits: updated.forgottenHabits,
          showFriendBadges: updated.showFriendBadges
        });
      }
      return finalName;
    }

    HABITU_FIREBASE_AUTH.onAuthStateChanged(async user => {
      if (!user) {
        if (currentProfile?.guest) {
          hideLoaderOverlay();
          hideAuthOverlay();
          updateAddModalOptions();
          showLoaderOverlay();
          try {
            await loadLibraryData();
          } finally {
            hideLoaderOverlay();
          }
          showHome();
          return;
        }
        persistProfile(null);
        clearLocalState();
        showAuthOverlay();
        clearResetNotice();
        updateAuthMessage();
        return;
      }
      const isGuest = user.isAnonymous;
      const email = (user.email || '').toLowerCase();
      const inviteName = pendingInviteInfo?.invitedName || '';
      const name = user.displayName || currentProfile?.name || inviteName || userName || 'Moi';
      const remoteProfile = await loadRemoteUserProfile(user.uid);
      const fallbackTips = currentProfile?.tipsDisplayMode;
      const tipsDisplayMode = remoteProfile?.tipsDisplayMode || fallbackTips || 'auto';
      const pinnedHabits = Array.isArray(remoteProfile?.pinnedHabits) ? remoteProfile.pinnedHabits : [];
      const postponedHabits = normalizePostponedMap(remoteProfile?.postponedHabits);
      const forgottenHabits = Array.isArray(remoteProfile?.forgottenHabits) ? remoteProfile?.forgottenHabits : [];
      const showFriendBadges = remoteProfile?.showFriendBadges !== false;
      const resolvedPseudo = remoteProfile?.pseudo || currentProfile?.pseudo || '';
      const resolvedMode = remoteProfile?.profileMode || currentProfile?.profileMode || DEFAULT_PROFILE_MODE;
      const profile = {
        uid: user.uid,
        email,
        name,
        guest: isGuest,
        tipsDisplayMode,
        pinnedHabits,
        postponedHabits,
        forgottenHabits,
        showFriendBadges,
        pseudo: resolvedPseudo,
        profileMode: resolvedMode
      };
      persistProfile(profile);
      await persistUserProfile(profile);
      await ensureProfilePseudo();
      if (!isGuest) {
        await linkGuestSpacesToEmail(email);
        await acceptPendingInvite(email);
        hideAuthOverlay();
        showLoaderOverlay();
        try {
          await resetFirestoreState(currentProfile);
        } finally {
          hideLoaderOverlay();
        }
        await ensureProfileName(inviteName || name);
        userName = currentProfile?.name || name;
        setLastMemberName(userName);
        updateAddModalOptions();
        if (allowedSpaces.length === 0) { await ensureProfileSetup(); await createPersonalSpace(); return; }
        updAll();
        showHome();
        triggerPersonalActivityRefresh();
      } else {
        hideAuthOverlay();
        updateAddModalOptions();
        showLoaderOverlay();
        try {
          await loadLibraryData();
          await refreshGuestSpaces();
        } finally {
          hideLoaderOverlay();
        }
        if (allowedSpaces.length === 0) { await ensureProfileSetup(); await createPersonalSpace(); return; }
        updAll();
        showHome();
        triggerPersonalActivityRefresh();
      }
    });

    /* Tabs util */
    let statsSortDirection = 'desc';
    function sortSpaceStats(direction = 'desc') {
      const tbody = document.querySelector('#sstats table tbody');
      if (!tbody) return;
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const factor = direction === 'asc' ? 1 : -1;
      rows.sort((a, b) => {
        const aVal = Number(a.dataset.streak) || 0;
        const bVal = Number(b.dataset.streak) || 0;
        return (aVal - bVal) * factor;
      });
      rows.forEach(row => tbody.appendChild(row));
      const header = document.querySelector('#sstats th[data-sortable]');
      if (header) {
        header.dataset.direction = direction === 'asc' ? 'â†‘' : 'â†“';
      }
      statsSortDirection = direction;
    }
    function setupSpaceStatsSorting() {
      const header = document.querySelector('#sstats th[data-sortable]');
      if (!header) return;
      const toggleDirection = () => {
        const next = statsSortDirection === 'asc' ? 'desc' : 'asc';
        sortSpaceStats(next);
      };
      header.addEventListener('click', toggleDirection);
      sortSpaceStats(statsSortDirection);
    }
    function switchViews(btn, groupAttr, prefix) {
      const key = btn.getAttribute(groupAttr);
      document.querySelectorAll(`.tabs [${groupAttr}]`).forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.querySelectorAll(`#${prefix} .view`).forEach(v => v.classList.remove('active'));
      const target = document.querySelector(`#${prefix} #${(groupAttr === 'data-tab' ? 'tab-' : '')}${key}`);
      if (target) target.classList.add('active');
      if (prefix === 'detail' && key === 'gardeners') {
        renderHabitGardeners();
      }
      if (prefix === 'space' && key === 'sparams') {
        syncSpacePreferenceControls();
      }
      if (prefix === 'space' && key === 'sstats') {
        sortSpaceStats(statsSortDirection);
      }
      if (key === 'shistory') { populateSpaceWho?.(); renderSpaceCalendar?.() }
    }
    document.querySelectorAll('#detail .tabs [data-tab]').forEach(btn => { btn.addEventListener('click', () => switchViews(btn, 'data-tab', 'detail')) });
    document.querySelectorAll('#space .tabs [data-stab]').forEach(btn => { btn.addEventListener('click', () => switchViews(btn, 'data-stab', 'space')) });
    setupSpaceStatsSorting();
    let swRegistration = null;
    let updateRequestInProgress = false;
    async function ensureSwRegistration() {
      if (!('serviceWorker' in navigator)) return null;
      if (swRegistration) return swRegistration;
      try {
        swRegistration = await navigator.serviceWorker.ready;
        return swRegistration;
      } catch (err) {
        console.warn('ensureSwRegistration', err);
        return null;
      }
    }
    async function clearAppCaches() {
      if (!('caches' in window)) return;
      try {
        const keys = await caches.keys();
        await Promise.all(keys.map(key => caches.delete(key)));
      } catch (err) {
        console.warn('clearAppCaches', err);
      }
    }
    async function handleAppUpdateRequest({ auto = false } = {}) {
      if (updateRequestInProgress) {
        return;
      }
      if (!('serviceWorker' in navigator)) {
        console.warn('Service worker indisponible.');
        return;
      }
      const loaderWasVisible = loaderOverlay && !loaderOverlay.classList.contains('hide');
      if (!loaderWasVisible) {
        showLoaderOverlay();
      }
      updateRequestInProgress = true;
      try {
        await clearAppCaches();
        const registration = await ensureSwRegistration();
        if (!registration) {
          console.warn('Service worker introuvable.');
          return;
        }
        await registration.update();
        if (registration.waiting) {
          registration.waiting.postMessage({ type: 'SKIP_WAITING' });
        }
      } catch (err) {
        console.warn('handleAppUpdateRequest', err);
      } finally {
        updateRequestInProgress = false;
        if (!loaderWasVisible) {
          hideLoaderOverlay();
        }
      }
    }
    async function initAutoUpdater() {
      const registration = await ensureSwRegistration();
      if (!registration) return;
      registration.addEventListener('updatefound', () => handleAppUpdateRequest({ auto: true }));
      await handleAppUpdateRequest({ auto: true });
    }
    initAutoUpdater();
    const canUseServiceWorker = !['file:'].includes(window.location.protocol);
    if ('serviceWorker' in navigator && canUseServiceWorker) {
      const registerServiceWorker = async () => {
        try {
          const registration = await navigator.serviceWorker.register('/service-worker.js', { scope: './' });
          swRegistration = registration;
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (!newWorker) return;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                newWorker.postMessage({ type: 'SKIP_WAITING' });
              }
            });
          });
        } catch (err) {
          console.warn('SW registration failed', err);
        }
      };

      let refreshing = false;
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (refreshing) return;
        refreshing = true;
        window.location.reload();
      });

      window.addEventListener('load', registerServiceWorker);
    }
  </script>
</body>

</html>
